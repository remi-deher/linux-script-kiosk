#!/bin/bash
# ===========================
#  MANAGER SERVEUR WEB
# ===========================

# --- CONFIGURATION SYSTEME ---
CONF_DIR="/etc/nginx-manager"
CONFIG_FILE="$CONF_DIR/.nginx-manager.conf"
BACKUP_LIST_FILE="$CONF_DIR/destinations.list"

# --- VALEURS PAR D√âFAUT ---
INFOMANIAK_TOKEN=""
INFOMANIAK_DOMAIN=""
ZORAXY_IP="127.0.0.1"
ZORAXY_PORT="8000"
BACKUP_DEFAULT_ENABLED="true"

# --- UTILITAIRES DE BASE ---
ask_sudo_gui() {
    if sudo -n true 2>/dev/null; then
        return 0
    fi
    echo -e "\n${YELLOW}üîí Authentification requise${NC}"
    read -s -p "Mot de passe : " user_pass
    echo ""
    echo "$user_pass" | sudo -S -v 2>/dev/null
    return $?
}

run_sudo() { sudo -n "$@" 2>/dev/null || sudo "$@"; }
run_sudo_silent() { sudo -n "$@" 2>/dev/null; }
pause() {
    echo ""
    read -p "Appuyez sur Entr√©e pour continuer..." x
}

# --- COULEURS & STYLE ---
BLUE=$'\033[0;34m'; GREEN=$'\033[0;32m'; RED=$'\033[0;31m'; YELLOW=$'\033[1;33m'
CYAN=$'\033[0;36m'; GREY=$'\033[1;30m'; NC=$'\033[0m';
BOLD=$'\033[1m'
SEP="------------------------------------------------"
SEP_RED="${RED}------------------------------------------------${NC}"

# --- INITIALISATION ---
init_config_structure() {
    if [ ! -d "$CONF_DIR" ]; then
        echo -e "${YELLOW}Initialisation de la configuration dans $CONF_DIR...${NC}"
        if ask_sudo_gui; then
            run_sudo mkdir -p "$CONF_DIR"
            run_sudo chmod 755 "$CONF_DIR"
        else
            echo -e "${RED}Impossible de cr√©er le dossier de configuration.${NC}"
            exit 1
        fi
    fi
    
    [ ! -f "$CONFIG_FILE" ] && { run_sudo touch "$CONFIG_FILE"; run_sudo chmod 664 "$CONFIG_FILE"; }
    [ ! -f "$BACKUP_LIST_FILE" ] && { run_sudo touch "$BACKUP_LIST_FILE"; run_sudo chmod 664 "$BACKUP_LIST_FILE"; }

    if [ -r "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
    [ -z "$BACKUP_DEFAULT_ENABLED" ] && BACKUP_DEFAULT_ENABLED="true"
}
init_config_structure

# --- VARIABLES CALCUL√âES ---
ZORAXY_API_URL="http://$ZORAXY_IP:$ZORAXY_PORT"
CACHED_Z_USER=""
CACHED_Z_PASS=""

DIR_WEB="/var/www"
NGINX_HOME="/etc/nginx"
DIR_PHP="/etc/php"
SITES_AVAIL="$NGINX_HOME/sites-available"
SITES_ENAB="$NGINX_HOME/sites-enabled"
BACKUP_DIR="/var/backups/nginx-manager"
LOG_ACCESS="/var/log/nginx/access.log"
LOG_ERROR="/var/log/nginx/error.log"
CMD_NGINX="/usr/sbin/nginx"
CMD_UFW="/usr/sbin/ufw"

COOKIE_FILE="/tmp/zoraxy_cookie_manager.txt"
ZORAXY_SERVICE_NAME="zoraxy"
PUBLIC_IP_CACHE="/tmp/nginx_public_ip"

trap '' SIGINT SIGQUIT SIGTSTP

# =======================================================
#  0. GESTION DE LA CONFIGURATION
# =======================================================

save_config() {
    config_content=$(cat <<EOF
# Configuration Nginx Manager
INFOMANIAK_TOKEN="$INFOMANIAK_TOKEN"
INFOMANIAK_DOMAIN="$INFOMANIAK_DOMAIN"
ZORAXY_IP="$ZORAXY_IP"
ZORAXY_PORT="$ZORAXY_PORT"
BACKUP_DEFAULT_ENABLED="$BACKUP_DEFAULT_ENABLED"
EOF
    )
    if [ -w "$CONFIG_FILE" ]; then
        echo "$config_content" > "$CONFIG_FILE"
    else
        echo "$config_content" | run_sudo tee "$CONFIG_FILE" > /dev/null
    fi
    ZORAXY_API_URL="http://$ZORAXY_IP:$ZORAXY_PORT"
}

settings_menu() {
    while true; do
        clear
        echo -e "${BLUE}################################################${NC}"
        echo -e "${BLUE}#           R√âGLAGES & CONFIGURATION           #${NC}"
        echo -e "${BLUE}################################################${NC}"

        echo -e "${BOLD}--- INFOMANIAK ---${NC}"
        if [ -n "$INFOMANIAK_TOKEN" ]; then
            mask="${INFOMANIAK_TOKEN:0:5}....................${INFOMANIAK_TOKEN: -5}"
        else
            mask="${RED}Non configur√©${NC}"
        fi
        echo -e "1. üîë Token API       : $mask"
        echo -e "2. üåç Domaine Racine  : ${CYAN}${INFOMANIAK_DOMAIN:-Non configur√©}${NC}"

        echo ""
        echo -e "${BOLD}--- ZORAXY ---${NC}"
        echo -e "3. üëΩ Adresse IP      : ${CYAN}$ZORAXY_IP${NC}"
        echo -e "4. üîå Port            : ${CYAN}$ZORAXY_PORT${NC}"
        if [ -f "$COOKIE_FILE" ]; then
            echo -e "   üç™ Session         : ${GREEN}Active${NC}"
        else
            echo -e "   üç™ Session         : ${RED}Aucune${NC}"
        fi

        CURRENT_GROUP=$(stat -c '%G' "$CONF_DIR" 2>/dev/null)
        echo ""
        echo -e "${BOLD}--- SYST√àME ---${NC}"
        echo -e "6. üë• Groupe Droits   : ${CYAN}$CURRENT_GROUP${NC}"

        echo ""
        echo -e "${BOLD}--- DEBUG ---${NC}"
        echo -e "5. üíÄ Tuer le Token/Session Zoraxy"
        echo -e "$SEP_RED"
        echo -e "0. üîô Retour au menu principal"
        echo -e "$SEP"

        read -p "Modifier l'option > " choice
        case "$choice" in
            1)
                echo -e "\n${YELLOW}Token Infomaniak :${NC}"
                read -p "> " t
                [ -n "$t" ] && INFOMANIAK_TOKEN="$t" && save_config
                ;;
            2)
                echo -e "\n${YELLOW}Domaine (ex: site.com) :${NC}"
                read -p "> " d
                [ -n "$d" ] && INFOMANIAK_DOMAIN="$d" && save_config
                ;;
            3)
                echo -e "\n${YELLOW}IP Zoraxy :${NC}"
                read -p "> " i
                [ -n "$i" ] && ZORAXY_IP="$i" && save_config
                ;;
            4)
                echo -e "\n${YELLOW}Port Zoraxy :${NC}"
                read -p "> " p
                [ -n "$p" ] && ZORAXY_PORT="$p" && save_config
                ;;
            5)
                rm -f "$COOKIE_FILE"; CACHED_Z_USER=""; CACHED_Z_PASS=""
                echo -e "${GREEN}Reset OK.${NC}"
                pause
                ;;
            6)
                echo -e "\n${YELLOW}Changement du groupe propri√©taire${NC}"
                read -p "Nouveau groupe (ex: $(id -gn)) : " new_grp
                if getent group "$new_grp" >/dev/null; then
                    if ask_sudo_gui; then
                        run_sudo chown -R :"$new_grp" "$CONF_DIR"
                        run_sudo chmod -R 775 "$CONF_DIR"
                        run_sudo chmod g+s "$CONF_DIR"
                        echo -e "${GREEN}OK.${NC}"
                    fi
                else
                    echo -e "${RED}Groupe inconnu.${NC}"
                fi
                pause
                ;;
            0) return ;;
            *) echo "Choix invalide"; sleep 1 ;;
        esac
    done
}

# =======================================================
#  1. FONCTIONS SYST√àME DE BASE
# =======================================================

ensure_requirements() {
    for cmd in jq curl git; do
        if ! command -v $cmd &> /dev/null; then
            echo -e "${RED}Erreur: '$cmd' requis.${NC}"
            exit 1
        fi
    done
    if ! command -v rclone &> /dev/null; then
        echo -e "${YELLOW}Note: 'rclone' absent (Backups Cloud d√©sactiv√©s).${NC}"
    fi
}

get_sys_info() {
    LOCAL_IP=$(hostname -I | awk '{print $1}')
    if [ -f "$PUBLIC_IP_CACHE" ] && [ $(( $(date +%s) - $(stat -c %Y "$PUBLIC_IP_CACHE") )) -lt 3600 ]; then
        PUBLIC_IP=$(cat "$PUBLIC_IP_CACHE")
    else
        PUBLIC_IP=$(curl -s -4 -m 3 https://icanhazip.com 2>/dev/null)
        [[ "$PUBLIC_IP" =~ ^[0-9.]+$ ]] && echo "$PUBLIC_IP" > "$PUBLIC_IP_CACHE" || PUBLIC_IP="N/A"
    fi
    OS_NAME=$(grep -oP 'PRETTY_NAME="\K[^"]+' /etc/os-release 2>/dev/null | cut -c1-20)
    RAM_USAGE=$(free -m | awk 'NR==2{printf "%.1f%% (%s/%sMB)", $3*100/$2, $3, $2 }')
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1"%"}')
    SITES_COUNT=$(ls -1 "$SITES_ENAB" 2>/dev/null | wc -l)

    if systemctl is-active --quiet nginx; then SX="${GREEN}‚óè ON${NC}"; else SX="${RED}‚óè OFF${NC}"; fi
    if run_sudo_silent $CMD_UFW status 2>/dev/null | grep -q "active"; then FW="${GREEN}‚óè ACTIF${NC}"; else FW="${RED}‚óè INACTIF${NC}"; fi
}

normalize_domain_input() {
    local input="$1"
    local base="$INFOMANIAK_DOMAIN"
    if [ -z "$base" ]; then
        echo -e "${RED}Domaine non configur√© !${NC}"
        VAL_FQDN="$input"
        VAL_SUB="$input"
        return
    fi
    input="${input%.}"
    if [[ "$input" == *"$base" ]]; then
        VAL_FQDN="$input"
        VAL_SUB="${input%.$base}"
    else
        VAL_SUB="$input"
        VAL_FQDN="${input}.${base}"
    fi
}

check_port_free() {
    if sudo ss -tuln | grep -q ":$1 "; then
        return 1
    fi
    return 0
}

# =======================================================
#  2. API ZORAXY & INFOMANIAK
# =======================================================

check_zoraxy_health() {
    if curl -s -m 1 "$ZORAXY_API_URL/api/auth/username" >/dev/null; then return 0; fi
    echo -e "\n${RED}‚ö†Ô∏è  ALERTE : Zoraxy ne r√©pond plus !${NC}"
    run_sudo systemctl restart "$ZORAXY_SERVICE_NAME"
    for i in {1..15}; do
        if curl -s -m 1 "$ZORAXY_API_URL/api/auth/username" >/dev/null; then echo -e " ${GREEN}OK !${NC}"; return 0; fi
        echo -n "."
        sleep 1
    done
    return 1
}

ensure_zoraxy_auth() {
    if ! check_zoraxy_health; then return 1; fi
    if [ -f "$COOKIE_FILE" ]; then
        CHECK=$(curl -s -m 2 -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/api/auth/username")
        [[ "$CHECK" == *\"* ]] && [[ "$CHECK" != *"error"* ]] && return 0
    fi

    HOMEPAGE=$(curl -s -L -k -c "$COOKIE_FILE" -b "$COOKIE_FILE" "$ZORAXY_API_URL/" --max-time 2)
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    
    if [ -n "$CACHED_Z_USER" ]; then
        curl -s -k -X POST -c "$COOKIE_FILE" -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" -d "username=$CACHED_Z_USER" -d "password=$CACHED_Z_PASS" "$ZORAXY_API_URL/api/auth/login" >/dev/null
        if [ -f "$COOKIE_FILE" ]; then return 0; fi
    fi
    
    echo -e "\n${CYAN}üîê Authentification Zoraxy...${NC}"
    while true; do
        read -p "User: " u
        read -s -p "Pass: " p
        echo ""
        curl -s -k -X POST -c "$COOKIE_FILE" -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" -d "username=$u" -d "password=$p" "$ZORAXY_API_URL/api/auth/login" >/dev/null
        if [ -f "$COOKIE_FILE" ]; then
            echo -e "${GREEN}‚úÖ Connect√©.${NC}"
            CACHED_Z_USER="$u"
            CACHED_Z_PASS="$p"
            return 0
        else
            echo -e "${RED}Erreur.${NC}"
        fi
    done
}

api_req() {
    local endpoint="$1"
    shift
    local args=("$@")
    HOMEPAGE=$(curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/")
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" "${args[@]}" "$ZORAXY_API_URL$endpoint"
}

get_zoraxy_acls() { ensure_zoraxy_auth && curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/api/access/list" | jq -r '.[] | "\(.ID)|\(.Name)"' 2>/dev/null; }

add_zoraxy_host() {
    local d="$1"; local t="$2"; local a="$3"
    ensure_zoraxy_auth || return 1
    echo " > Zoraxy: Ajout $d -> $t"
    api_req "/api/proxy/add" --data-urlencode "type=host" --data-urlencode "rootname=$d" --data-urlencode "ep=$t" --data-urlencode "tls=false" >/dev/null
    [ -n "$a" ] && api_req "/api/access/attach" --data-urlencode "id=$a" --data-urlencode "host=$d" >/dev/null
    check_zoraxy_health
    return 0
}

request_zoraxy_ssl() {
    local d="$1"
    ensure_zoraxy_auth || return 1
    echo " > Zoraxy: üîë SSL..."
    api_req "/api/acme/obtainCert" --data-urlencode "domains=$d" --data-urlencode "filename=$d" --data-urlencode "email=admin@$d" --data-urlencode "ca=Let's Encrypt" --data-urlencode "skipTLS=false" --data-urlencode "dns=false" >/dev/null
    check_zoraxy_health
}

delete_zoraxy_host() {
    ensure_zoraxy_auth && api_req "/api/proxy/del" --data-urlencode "type=host" --data-urlencode "ep=$1" >/dev/null
    check_zoraxy_health
}

delete_zoraxy_cert() {
    ensure_zoraxy_auth && api_req "/api/cert/delete" --data-urlencode "file=$1" >/dev/null
}

create_infomaniak_record() {
    [ -z "$INFOMANIAK_TOKEN" ] && return 1
    local s="$1"
    local t="$2"
    local type="CNAME"
    [[ "$t" =~ ^[0-9]+\. ]] && type="A"
    echo " > Infomaniak: $type $s -> $t"
    JSON=$(jq -n --arg t "$type" --arg s "$s" --arg g "$t" '{type:$t,source:$s,target:$g,ttl:3600}')
    curl -s -X POST "https://api.infomaniak.com/1/domain/$INFOMANIAK_DOMAIN/dns/record" -H "Authorization: Bearer $INFOMANIAK_TOKEN" -H "Content-Type: application/json" -d "$JSON" >/dev/null
}

delete_infomaniak_record() {
    [ -z "$INFOMANIAK_TOKEN" ] && return 1
    ID=$(curl -s "https://api.infomaniak.com/1/domain/$INFOMANIAK_DOMAIN/dns/record" -H "Authorization: Bearer $INFOMANIAK_TOKEN" | jq -r --arg s "$1" '.data[]|select(.source==$s)|.id' | head -1)
    [ -n "$ID" ] && curl -s -X DELETE "https://api.infomaniak.com/1/domain/$INFOMANIAK_DOMAIN/dns/record/$ID" -H "Authorization: Bearer $INFOMANIAK_TOKEN" >/dev/null
}

# =======================================================
#  3. DEPLOIEMENT & SITES
# =======================================================

handle_github_setup() {
    local dir="$1"
    local url="$2"
    [ -d "$dir" ] && run_sudo rm -rf "$dir"/* "$dir"/.* 2>/dev/null
    run_sudo git clone "$url" "$dir" || return 1
    run_sudo chown -R $USER:www-data "$dir"
    echo "" > /tmp/nginx_webroot_suffix
    for d in public web dist html build; do
        [ -d "$dir/$d" ] && echo "/$d" > /tmp/nginx_webroot_suffix && break
    done
}

perform_rollback() {
    echo -e "\n${RED}üö® ROLLBACK EN COURS${NC}"
    [ "$RB_ZORAXY" -eq 1 ] && delete_zoraxy_host "$VAL_FQDN"
    [ "$RB_DNS" -eq 1 ] && delete_infomaniak_record "$VAL_SUB"
    [ "$RB_UFW" -eq 1 ] && run_sudo ufw delete allow "$RB_PORT/tcp" >/dev/null
    [ "$RB_NGINX" -eq 1 ] && { run_sudo rm "$SITES_AVAIL/$VAL_FQDN.conf" 2>/dev/null; run_sudo rm "$SITES_ENAB/$VAL_FQDN.conf" 2>/dev/null; run_sudo systemctl reload nginx; }
    [ "$RB_FOLDER" -eq 1 ] && run_sudo rm -rf "$DIR_WEB/$VAL_FQDN"
    echo "Nettoy√©."
    pause
}

core_deployment_wizard() {
    local mode="$1"
    RB_FOLDER=0; RB_NGINX=0; RB_UFW=0; RB_DNS=0; RB_ZORAXY=0
    RB_PORT=""
    [ -z "$INFOMANIAK_DOMAIN" ] && echo "${RED}Domaine non config.${NC}" && pause && return

    echo -e "\n${BLUE}=== WIZARD DEPLOIEMENT ===${NC}"
    read -p "Sous-domaine : " raw
    normalize_domain_input "$raw"
    echo -e "Domaine : ${CYAN}$VAL_FQDN${NC}"
    echo "1. Site Vierge | 2. GitHub"
    read -p "> " src
    [ "$src" == "2" ] && read -p "URL Git : " git_url
    
    while true; do
        read -p "Port Local : " port
        check_port_free "$port" && break
    done
    RB_PORT="$port"
    
    target="$INFOMANIAK_DOMAIN"
    [ "$mode" == "lan" ] && target="$LOCAL_IP"
    ACL_ID=""
    [ "$mode" == "lan" ] && ACL_ID=$(get_zoraxy_acls | grep -i "LAN" | head -1 | cut -d'|' -f1)
    
    read -p "SSL (o/n) ? " ssl

    echo -e "\n${BOLD}D√©ploiement sur $VAL_FQDN (Port $port)...${NC}"
    read -p "Confirmer ? (o/n) " c
    [ "$c" != "o" ] && return
    
    ask_sudo_gui || return
    docroot="$DIR_WEB/$VAL_FQDN"
    run_sudo mkdir -p "$docroot"
    RB_FOLDER=1
    
    if [ "$src" == "2" ]; then 
        handle_github_setup "$docroot" "$git_url" || { perform_rollback; return; }
        WEB_ROOT_SUFFIX=$(cat /tmp/nginx_webroot_suffix 2>/dev/null)
    else
        echo "<h1>$VAL_FQDN</h1>" | run_sudo tee "$docroot/index.html" >/dev/null
        run_sudo chown -R www-data:www-data "$docroot"
        WEB_ROOT_SUFFIX=""
    fi
    
    conf="$SITES_AVAIL/$VAL_FQDN.conf"
    cat <<EOF | run_sudo tee "$conf" > /dev/null
server {
    listen $port;
    server_name $VAL_FQDN _;
    root $docroot$WEB_ROOT_SUFFIX;
    index index.html index.php;
    absolute_redirect off;
    access_log /var/log/nginx/${VAL_SUB}_access.log;
    error_log /var/log/nginx/${VAL_SUB}_error.log;
    location / { try_files \$uri \$uri/ =404; }
}
EOF
    run_sudo ln -sf "$conf" "$SITES_ENAB/$VAL_FQDN.conf"
    if ! run_sudo systemctl reload nginx; then perform_rollback; return; fi
    RB_NGINX=1
    
    run_sudo ufw allow "$port/tcp" >/dev/null
    RB_UFW=1
    create_infomaniak_record "$VAL_SUB" "$target" || { perform_rollback; return; }
    RB_DNS=1
    add_zoraxy_host "$VAL_FQDN" "$LOCAL_IP:$port" "$ACL_ID" || { perform_rollback; return; }
    RB_ZORAXY=1
    [ "$ssl" == "o" ] && request_zoraxy_ssl "$VAL_FQDN"
    
    echo -e "${GREEN}Termin√©.${NC}"
    pause
}

wizard_link_orphan_site() {
    ensure_zoraxy_auth || return
    echo "Scan des sites orphelins..."
    Z_PORTS_STRING=" $(api_req "/api/proxy/list" --data-urlencode "type=host" | jq -r 'to_entries[] | .value.ActiveOrigins[0].OriginIpOrDomain' | sed 's/.*://' | grep -oE "[0-9]+" | tr '\n' ' ') "
    declare -a ORPHAN_FILES
    declare -a ORPHAN_PORTS
    idx=0
    
    shopt -s nullglob
    for f in "$SITES_AVAIL"/*; do
        port=$(grep -E "^\s*listen" "$f" | grep -oE "[0-9]+" | head -n1)
        if [ -n "$port" ] && [[ "$Z_PORTS_STRING" != *" $port "* ]]; then
            ORPHAN_FILES[$idx]="$f"
            ORPHAN_PORTS[$idx]="$port"
            ((idx++))
        fi
    done
    shopt -u nullglob
    
    if [ $idx -eq 0 ]; then
        echo "Tous les sites sont li√©s."
        pause
        return
    fi
    for ((i=0; i<idx; i++)); do
        echo "$((i+1)). $(basename "${ORPHAN_FILES[$i]}") (Port: ${ORPHAN_PORTS[$i]})"
    done
    read -p "Choix > " sel
    [ -z "$sel" ] && return
    
    sel_idx=$((sel-1))
    TARGET_PORT="${ORPHAN_PORTS[$sel_idx]}"
    read -p "Domaine Public : " input_domain
    VAL_FQDN="$input_domain"
    add_zoraxy_host "$VAL_FQDN" "127.0.0.1:$TARGET_PORT"
    read -p "SSL ? (o/n) " ssl
    [ "$ssl" == "o" ] && request_zoraxy_ssl "$VAL_FQDN"
    pause
}

create_simple_vhost_wizard() {
    echo -e "\n${GREEN}‚ûï SITE SIMPLE (IP:PORT)${NC}"
    read -p "Nom du projet : " d
    [ -z "$d" ] && return
    while true; do
        read -p "Port : " port
        check_port_free "$port" && break
    done
    ask_sudo_gui || return
    run_sudo mkdir -p "$DIR_WEB/$d"
    echo "<h1>Site $d</h1>" | run_sudo tee "$DIR_WEB/$d/index.html" >/dev/null
    run_sudo chown -R www-data:www-data "$DIR_WEB/$d"
    conf="$SITES_AVAIL/$d.conf"
    echo "server { listen $port; server_name _; root $DIR_WEB/$d; index index.html; absolute_redirect off; }" | run_sudo tee "$conf" >/dev/null
    run_sudo ln -sf "$conf" "$SITES_ENAB/$d.conf"
    run_sudo ufw allow "$port/tcp" >/dev/null
    run_sudo systemctl reload nginx
    echo "OK."
    pause
}

wizard_new_site_menu() {
    while true; do
        clear
        echo -e "${BLUE}################################################${NC}"
        echo -e "${BLUE}#             NOUVEAU SITE WEB                 #${NC}"
        echo -e "${BLUE}################################################${NC}"
        
        echo -e " ${BOLD}${CYAN}üåê TYPE DE D√âPLOIEMENT${NC}"
        echo -e "    ${GREEN}1.${NC} üåç Site Public (Internet)"
        echo -e "       ${GREY}(Nginx + Certificat SSL + Zoraxy + DNS)${NC}"
        echo ""
        echo -e "    ${GREEN}2.${NC} üè† Site Priv√© (LAN / VPN)"
        echo -e "       ${GREY}(Nginx + ACL Zoraxy interne)${NC}"
        echo ""
        echo -e "    ${GREEN}3.${NC} üîó Lier un site existant (Orphelin)"
        echo -e "       ${GREY}(D√©tecte les vhosts Nginx non connect√©s √† Zoraxy)${NC}"
        
        echo -e "$SEP_RED"
        echo -e "  ${RED}0.${NC} Retour"
        echo -e "$SEP"

        read -p "  Votre choix > " c
        case "$c" in
            1) core_deployment_wizard "public" ;;
            2)
                echo "1. Avec Domaine | 2. IP Directe"
                read -p "> " s
                [ "$s" == "1" ] && core_deployment_wizard "lan"
                [ "$s" == "2" ] && create_simple_vhost_wizard
                ;;
            3) wizard_link_orphan_site ;;
            0) return ;;
        esac
    done
}

# --- ACTIONS SUPPLEMENTAIRES (DASHBOARD) ---
declare -a VHOST_FILES

action_toggle_vhost() {
    refresh_dashboard_table
    read -p "Site # (0=Retour) : " sel
    [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"
    bn=$(basename "$f")
    if ask_sudo_gui; then
        if ls "$SITES_ENAB/$bn"* 1>/dev/null 2>&1; then
            run_sudo rm "$SITES_ENAB/$bn"*
            echo "D√©sactiv√©."
        else
            run_sudo ln -sf "$f" "$SITES_ENAB/$bn"
            echo "Activ√©."
        fi
        run_sudo systemctl reload nginx
        pause
    fi
}

action_edit_vhost() {
    refresh_dashboard_table
    read -p "Site # (0=Retour) : " sel
    [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"
    if ask_sudo_gui; then
        run_sudo cp "$f" "$f.bak_tmp"
        run_sudo nano "$f"
        if run_sudo nginx -t; then
            run_sudo rm "$f.bak_tmp"
            run_sudo systemctl reload nginx
        else
            echo "Erreur Config!"
            run_sudo mv "$f.bak_tmp" "$f"
        fi
        pause
    fi
}

action_delete_wizard() {
    refresh_dashboard_table
    read -p "Site # √† SUPPRIMER (0=Retour) : " sel
    [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"
    filename=$(basename "$f")
    content=$(sudo cat "$f" 2>/dev/null)
    domain_conf=$(echo "$content" | grep "server_name" | awk '{print $2}' | sed 's/;//')
    [ "$domain_conf" == "_" ] && domain_conf="${filename%.*}"
    normalize_domain_input "$domain_conf"
    
    echo -e "${RED}SUPPRESSION DE $domain_conf${NC}"
    read -p "Supprimer dossier web ? (o/n) " del_web
    read -p "Supprimer Proxy Zoraxy ? (o/n) " del_proxy
    read -p "Supprimer SSL ? (o/n) " del_cert
    read -p "Supprimer DNS Infomaniak ? (o/n) " del_dns
    read -p "CONFIRMER (oui) : " confirm
    [ "$confirm" != "oui" ] && return
    
    ask_sudo_gui || return
    [ "$del_dns" == "o" ] && delete_infomaniak_record "$VAL_SUB"
    [ "$del_proxy" == "o" ] && delete_zoraxy_host "$VAL_FQDN"
    [ "$del_cert" == "o" ] && delete_zoraxy_cert "$VAL_FQDN.pem"
    
    port=$(echo "$content" | grep -E "^\s*listen" | grep -oE "[0-9]+" | head -n1)
    [ -n "$port" ] && run_sudo ufw delete allow "$port/tcp" >/dev/null
    
    run_sudo rm "$f"
    run_sudo rm "$SITES_ENAB/$filename" 2>/dev/null
    run_sudo systemctl reload nginx
    [ "$del_web" == "o" ] && run_sudo rm -rf "$DIR_WEB/$domain_conf"
    echo "Termin√©."
    pause
}

action_ssl_retry() {
    refresh_dashboard_table
    read -p "Site # : " sel
    [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"
    filename=$(basename "$f")
    request_zoraxy_ssl "${filename%.*}"
    pause
}

action_cleanup_ssl() {
    ensure_zoraxy_auth || return
    CERTS=$(api_req "/api/cert/list" | jq -r 'if type=="array" then .[] else keys[] end')
    [ -z "$CERTS" ] && return
    echo "Liste des certificats :"
    echo "$CERTS"
    read -p "Nom exact du certificat √† supprimer : " c
    [ -n "$c" ] && delete_zoraxy_cert "$c" && echo "Supprim√©." && pause
}

# --- TABLEAU DE BORD ---
refresh_dashboard_table() {
    VHOST_FILES=()
    declare -a T_DOMAINS T_PORTS T_ROOTS T_STATUS_TXT T_STATUS_COLOR
    local max_d=15
    local max_p=10; local max_r=15; local max_s=15
    shopt -s nullglob
    for f in "$SITES_AVAIL"/*; do
        [ -f "$f" ] && VHOST_FILES+=("$f")
    done
    shopt -u nullglob

    ensure_zoraxy_auth
    Z_PROXY_DOMAINS=$(api_req "/api/proxy/list" --data-urlencode "type=host" | jq -r 'to_entries[] | .value.RootOrMatchingDomain' 2>/dev/null)
    Z_CERT_DOMAINS=$(api_req "/api/cert/list" | jq -r 'if type=="array" then .[] else keys[] end' 2>/dev/null | sed 's/\.pem//g; s/\.crt//g')

    count=0
    for conf_file in "${VHOST_FILES[@]}"; do
        filename=$(basename "$conf_file")
        [[ "$filename" == "default" || "$filename" == .* ]] && continue
        
        raw_port=$(grep -E "^\s*listen" "$conf_file" | head -n 1 | grep -oE "[0-9]+" | head -n 1)
        port="${raw_port:-Inconnu}"
        domain=$(grep "server_name" "$conf_file" | head -1 | awk '{$1=""; print $0}' | tr -d ';' | xargs)
        root_web=$(grep "root" "$conf_file" | head -1 | awk '{print $2}' | tr -d ';')
        
        [ -z "$domain" ] && domain="($filename)"
        [ -z "$root_web" ] && root_web="-"

        has_nginx_ssl=false
        grep -qE "^\s*listen.*443|^\s*ssl_certificate" "$conf_file" && has_nginx_ssl=true
        has_zoraxy_proxy=false
        echo "$Z_PROXY_DOMAINS" | grep -Fqx "$domain" && has_zoraxy_proxy=true
        has_zoraxy_cert=false
        echo "$Z_CERT_DOMAINS" | grep -Fqx "$domain" && has_zoraxy_cert=true

        if [ "$has_zoraxy_proxy" = true ] && [ "$has_zoraxy_cert" = true ]; then
            s_txt="G√âR√âE PAR ZORAXY (SSL)"
            s_col="$CYAN"
        elif [ "$has_nginx_ssl" = true ]; then
            s_txt="G√âR√âE PAR NGINX"
            s_col="$YELLOW"
        else
            s_txt="PAS S√âCURIS√â"
            s_col="$RED"
        fi

        T_DOMAINS+=("$domain")
        T_PORTS+=("$port")
        T_ROOTS+=("$root_web")
        T_STATUS_TXT+=("$s_txt")
        T_STATUS_COLOR+=("$s_col")
        [ ${#domain} -gt $max_d ] && max_d=${#domain}
        [ ${#port} -gt $max_p ] && max_p=${#port}
        [ ${#root_web} -gt $max_r ] && max_r=${#root_web}
        [ ${#s_txt} -gt $max_s ] && max_s=${#s_txt}
        count=$((count+1))
    done

    max_d=$((max_d+2))
    max_p=$((max_p+2)); max_r=$((max_r+2))
    echo -e "${BLUE}=== TABLEAU DE BORD DES SITES WEB ===${NC}"
    printf "%-4s %-${max_d}s %-${max_p}s %-${max_r}s %s\n" "ID" "DOMAINE PUBLIC" "PORT" "RACINE WEB" "S√âCURIT√â"
    total_len=$((4 + max_d + max_p + max_r + max_s + 5))
    for ((i=0; i<total_len; i++)); do echo -n "-"; done; echo ""

    if [ $count -eq 0 ]; then
        echo "Aucun site trouv√©."
    else
        for ((i=0; i<count; i++)); do
            printf "%-4s %-${max_d}s %-${max_p}s %-${max_r}s %b%s%b\n" "$((i+1))" "${T_DOMAINS[$i]}" "${T_PORTS[$i]}" "${T_ROOTS[$i]}" "${T_STATUS_COLOR[$i]}" "${T_STATUS_TXT[$i]}" "$NC"
        done
    fi
    for ((i=0; i<total_len; i++)); do echo -n "-"; done; echo ""
}

menu_ssl_manager() {
    while true; do
        clear; echo -e "${BLUE}=== SSL MANAGER ===${NC}"
        echo "1. Renouveler/Forcer | 2. Nettoyer | 0. Retour"
        read -p "> " c
        case "$c" in
            1) action_ssl_retry ;;
            2) action_cleanup_ssl ;;
            0) return ;;
        esac
    done
}

manage_nginx_sites_menu() {
    while true; do
        clear
        refresh_dashboard_table
        
        echo ""
        echo -e " ${BOLD}${CYAN}‚ö° ACTIONS SUR LES SITES${NC}"
        echo -e "    ${GREEN}1.${NC} ‚ûï Ajouter un nouveau site"
        echo -e "    ${GREEN}2.${NC} ‚èØÔ∏è  Activer / D√©sactiver un site"
        echo -e "    ${GREEN}3.${NC} üìù Modifier la configuration (Nginx)"
        echo -e "    ${RED}4.${NC} üóëÔ∏è  Supprimer un site (Web + Proxy + DNS)"
        echo ""

        echo -e " ${BOLD}${CYAN}üîê S√âCURIT√â & SSL${NC}"
        echo -e "    ${GREEN}5.${NC} üõ°Ô∏è  Gestion des certificats (Renouveler/Nettoyer)"

        echo -e "$SEP_RED"
        echo -e "  ${RED}0.${NC} Retour au Menu Principal"
        echo -e "$SEP"

        read -r -p "  Votre choix > " ch
        case "$ch" in
            1) wizard_new_site_menu ;;
            2) action_toggle_vhost ;;
            3) action_edit_vhost ;;
            4) action_delete_wizard ;;
            5) menu_ssl_manager ;;
            0) return ;;
            *) echo "Choix invalide"; sleep 1 ;;
        esac
    done
}

# =======================================================
#  4. MODULE SAUVEGARDE AVANC√âE (/etc + Rclone)
# =======================================================

wizard_add_destination() {
    echo -e "\n${BLUE}=== ASSISTANT AJOUT DE DESTINATION ===${NC}"
    echo "Choisissez le type de destination :"
    echo "1. üìÇ Dossier Local (Disque dur / Cl√© USB)"
    echo "2. üîå Montage SMB/CIFS (Windows / NAS Synology)"
    echo "3. üêß Montage NFS (Linux / NAS QNAP)"
    echo "4. ‚òÅÔ∏è  Remote Rclone (S3 / Google Drive / Dropbox)"
    echo "0. Annuler"
    
    read -p "> " dtype

    case "$dtype" in
        1) # LOCAL
            echo -e "\n${YELLOW}Chemin absolu du dossier (ex: /mnt/backup_usb) :${NC}"
            read -p "> " path
            if [ ! -d "$path" ]; then
                echo -e "${YELLOW}Le dossier n'existe pas. Le cr√©er ? (o/n)${NC}"
                read -p "> " c
                if [ "$c" == "o" ]; then
                    if ask_sudo_gui; then
                        run_sudo mkdir -p "$path"
                        run_sudo chmod 775 "$path"
                        echo -e "${GREEN}Dossier cr√©√©.${NC}"
                    else
                        return
                    fi
                else
                    return
                fi
            fi
            if [ $WRITABLE -eq 1 ]; then
                echo "$path" >> "$BACKUP_LIST_FILE"
            else
                echo "$path" | run_sudo tee -a "$BACKUP_LIST_FILE" >/dev/null
            fi
            echo -e "${GREEN}Destination ajout√©e.${NC}"
            pause
            ;;
        2) 
            if ! command -v mount.cifs &>/dev/null; then
                echo -e "${RED}'cifs-utils' manquant.${NC}"
                ask_sudo_gui && run_sudo apt install -y cifs-utils || return
            fi
            read -p "Adresse (//192.168.x.x/partage) : " share
            read -p "Point de montage (/mnt/nas) : " mp
            read -p "User SMB : " su
            read -s -p "Pass SMB : " sp
            echo ""
            [ ! -d "$mp" ] && ask_sudo_gui && run_sudo mkdir -p "$mp"
            if ask_sudo_gui; then
                if run_sudo mount -t cifs -o "username=$su,password=$sp" "$share" "$mp"; then
                    echo "${GREEN}OK${NC}"
                    echo "$share $mp cifs username=$su,password=$sp,iocharset=utf8 0 0" | run_sudo tee -a /etc/fstab >/dev/null
                    if [ $WRITABLE -eq 1 ]; then
                        echo "$mp" >> "$BACKUP_LIST_FILE"
                    else
                        echo "$mp" | run_sudo tee -a "$BACKUP_LIST_FILE" >/dev/null
                    fi
                else
                    echo "${RED}Echec.${NC}"
                fi
            fi
            pause
            ;;
        3) 
            if ! command -v mount.nfs &>/dev/null; then
                echo -e "${RED}'nfs-common' manquant.${NC}"
                ask_sudo_gui && run_sudo apt install -y nfs-common || return
            fi
            read -p "Chemin NFS (IP:/vol) : " share
            read -p "Point de montage (/mnt/nfs) : " mp
            [ ! -d "$mp" ] && ask_sudo_gui && run_sudo mkdir -p "$mp"
            if ask_sudo_gui; then
                if run_sudo mount -t nfs "$share" "$mp"; then
                    echo "${GREEN}OK${NC}"
                    echo "$share $mp nfs defaults 0 0" | run_sudo tee -a /etc/fstab >/dev/null
                    if [ $WRITABLE -eq 1 ]; then
                        echo "$mp" >> "$BACKUP_LIST_FILE"
                    else
                        echo "$mp" | run_sudo tee -a "$BACKUP_LIST_FILE" >/dev/null
                    fi
                else
                    echo "${RED}Echec.${NC}"
                fi
            fi
            pause
            ;;
        4)
            if ! command -v rclone &> /dev/null; then
                echo "${RED}Rclone absent.${NC}"
                pause
                return
            fi
            rclone listremotes
            read -p "Remote (nom:bucket) > " rem
            if [[ "$rem" == *":"* ]]; then
                if [ $WRITABLE -eq 1 ]; then
                    echo "rclone:$rem" >> "$BACKUP_LIST_FILE"
                else
                    echo "rclone:$rem" | run_sudo tee -a "$BACKUP_LIST_FILE" >/dev/null
                fi
                echo -e "${GREEN}Ajout√©.${NC}"
            fi
            pause
            ;;
    esac
}

manage_backup_destinations() {
    while true; do
        clear
        echo -e "${BLUE}################################################${NC}"
        echo -e "${BLUE}#         GESTION DESTINATIONS BACKUP          #${NC}"
        echo -e "${BLUE}################################################${NC}"
        
        if [ -w "$BACKUP_LIST_FILE" ]; then
            echo -e "Mode : ${GREEN}üîì √âcriture directe${NC}"
            WRITABLE=1
        else
            echo -e "Mode : ${YELLOW}üîí Sudo requis${NC}"
            WRITABLE=0
        fi
        echo ""
        echo -e "${BOLD}--- DESTINATIONS ---${NC}"
        
        if [ "$BACKUP_DEFAULT_ENABLED" == "true" ]; then
            echo -e "  ${CYAN}1.${NC} [${GREEN}ON${NC}]  üìÇ $BACKUP_DIR (Local D√©faut)"
        else
            echo -e "  ${CYAN}1.${NC} [${RED}OFF${NC}] üìÇ $BACKUP_DIR (Local D√©faut)"
        fi

        idx=2
        if [ -s "$BACKUP_LIST_FILE" ]; then
            while IFS= read -r line; do
                [ -z "$line" ] && continue
                if [[ "$line" == \#* ]]; then
                    status="[${RED}OFF${NC}]"
                    clean="${line#\#}"
                else
                    status="[${GREEN}ON${NC}] "
                    clean="$line"
                fi
                if [[ "$clean" == "rclone:"* ]]; then
                    echo -e "  ${CYAN}$idx.${NC} $status ‚òÅÔ∏è  ${clean#rclone:}"
                else
                    echo -e "  ${CYAN}$idx.${NC} $status üìÇ $clean"
                fi
                ((idx++))
            done < "$BACKUP_LIST_FILE"
        fi
        echo ""
        echo -e " ${BOLD}${CYAN}‚ö° ACTIONS${NC}"
        echo -e "    ${GREEN}A.${NC} ‚ûï Ajouter une destination (Wizard)"
        echo -e "    ${GREEN}B.${NC} ‚èØÔ∏è  Activer / D√©sactiver une destination"
        echo -e "    ${RED}C.${NC} üóëÔ∏è  Supprimer une destination"
        echo -e "$SEP_RED"
        echo -e "  ${RED}0.${NC} Retour"
        echo -e "$SEP"

        read -p "  Votre choix > " ch
        case "$ch" in
            A|a) wizard_add_destination ;;
            B|b)
                read -p "Num√©ro √† basculer (1=D√©faut) : " n
                if [ "$n" == "1" ]; then
                    [ "$BACKUP_DEFAULT_ENABLED" == "true" ] && BACKUP_DEFAULT_ENABLED="false" || BACKUP_DEFAULT_ENABLED="true"
                    save_config
                elif [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -ge 2 ]; then
                    ln=$((n-1))
                    lc=$(sed "${ln}q;d" "$BACKUP_LIST_FILE")
                    if [ -n "$lc" ]; then
                        if [[ "$lc" == \#* ]]; then 
                            if [ $WRITABLE -eq 1 ]; then
                                sed -i "${ln}s/^#//" "$BACKUP_LIST_FILE"
                            else
                                run_sudo sed -i "${ln}s/^#//" "$BACKUP_LIST_FILE"
                            fi
                        else 
                            if [ $WRITABLE -eq 1 ]; then
                                sed -i "${ln}s/^/#/" "$BACKUP_LIST_FILE"
                            else
                                run_sudo sed -i "${ln}s/^/#/" "$BACKUP_LIST_FILE"
                            fi
                        fi
                    fi
                fi
                ;;
            C|c)
                read -p "Num√©ro √† supprimer (>=2) : " n
                if [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -ge 2 ]; then
                    ln=$((n-1))
                    if [ $WRITABLE -eq 1 ]; then
                        sed -i "${ln}d" "$BACKUP_LIST_FILE"
                    else
                        run_sudo sed -i "${ln}d" "$BACKUP_LIST_FILE"
                    fi
                fi
                ;;
            0) return ;;
        esac
    done
}

perform_backup_routine() {
    local IS_CRON="$1"
    local SCOPE="$2"
    
    [ -z "$SCOPE" ] && SCOPE="FULL"

    DATE_STR=$(date +%Y%m%d_%H%M%S)
    TEMP_BACKUP="/tmp/BACKUP_${SCOPE//:/_}_${DATE_STR}.tar.gz"

    LIST_RUN="/tmp/nginx_backup_run.list"
    > "$LIST_RUN"
    if [ "$BACKUP_DEFAULT_ENABLED" != "false" ]; then
        echo "$BACKUP_DIR" >> "$LIST_RUN"
    fi
    if [ -f "$BACKUP_LIST_FILE" ]; then
        grep -v "^#" "$BACKUP_LIST_FILE" >> "$LIST_RUN"
    fi
    
    if [ ! -s "$LIST_RUN" ]; then
        [ -z "$IS_CRON" ] && echo -e "${RED}‚õî ERREUR : Aucune destination de sauvegarde n'est active !${NC}"
        [ -z "$IS_CRON" ] && echo -e "Veuillez en activer une dans le menu 'Configurer destinations'."
        [ -z "$IS_CRON" ] && pause
        return 1
    fi

    # Pre-flight Check (SUDO)
    NEED_SUDO=0
    if [[ "$SCOPE" == "FULL" || "$SCOPE" == "CONFIGS" ]]; then NEED_SUDO=1; fi
    while IFS= read -r dest; do
        if [[ "$dest" != "rclone:"* ]]; then
            if [ -d "$dest" ] && [ ! -w "$dest" ]; then NEED_SUDO=1; fi
        fi
    done < "$LIST_RUN"

    if [ "$NEED_SUDO" -eq 1 ]; then
        if ! ask_sudo_gui; then return 1; fi
    fi

    [ -z "$IS_CRON" ] && echo -e "${BLUE}=== Lancement Sauvegarde ($SCOPE) ===${NC}"
    [ -z "$IS_CRON" ] && echo -n "üì¶ Compression des donn√©es... "

    case "$SCOPE" in
        "FULL")
            run_sudo tar -czf "$TEMP_BACKUP" --exclude='*.log' --exclude='.git' "$NGINX_HOME" "$DIR_PHP" "$DIR_WEB" "$CONF_DIR" 2>/dev/null
            ;;
        "CONFIGS")
            run_sudo tar -czf "$TEMP_BACKUP" --exclude='*.log' "$NGINX_HOME" "$DIR_PHP" "$CONF_DIR" 2>/dev/null
            ;;
        "WEB_ONLY")
            run_sudo tar -czf "$TEMP_BACKUP" --exclude='*.log' --exclude='.git' "$DIR_WEB" 2>/dev/null
            ;;
        SITE:*)
            TARGET_FILE="${SCOPE#SITE:}"
            VHOST_FULL_PATH=""
            if [ -e "$SITES_ENAB/$TARGET_FILE" ]; then
                VHOST_FULL_PATH=$(realpath "$SITES_ENAB/$TARGET_FILE")
            elif [ -f "$SITES_AVAIL/$TARGET_FILE" ]; then
                VHOST_FULL_PATH="$SITES_AVAIL/$TARGET_FILE"
            fi
            if [ -z "$VHOST_FULL_PATH" ]; then
                echo -e "${RED}Erreur: Vhost '$TARGET_FILE' introuvable.${NC}"
                return 1
            fi
            WEB_ROOT=$(run_sudo grep -E "^\s*root" "$VHOST_FULL_PATH" | head -1 | awk '{print $2}' | tr -d ';')
            if [ -z "$WEB_ROOT" ] || [ ! -d "$WEB_ROOT" ]; then
                echo -e "${RED}Erreur: Racine web introuvable ($WEB_ROOT)${NC}"
                return 1
            fi
            run_sudo tar -czf "$TEMP_BACKUP" --exclude='*.log' --exclude='.git' "$VHOST_FULL_PATH" "$WEB_ROOT" 2>/dev/null
            ;;
    esac

    if [ $? -eq 0 ]; then
        [ -z "$IS_CRON" ] && echo -e "${GREEN}OK${NC} ("$(run_sudo du -h "$TEMP_BACKUP" | cut -f1)")"
    else 
        [ -z "$IS_CRON" ] && echo -e "${RED}Erreur TAR${NC}"
        return 1
    fi

    while IFS= read -r dest; do
        [ -z "$dest" ] && continue
        if [[ "$dest" == "rclone:"* ]]; then
            real_dest="${dest#rclone:}"
            [ -z "$IS_CRON" ] && echo -n "‚òÅÔ∏è  Rclone -> $real_dest... "
            rclone copy "$TEMP_BACKUP" "$real_dest" >/dev/null 2>&1
            STATUS=$?
        else
            [ -z "$IS_CRON" ] && echo -n "üìÇ Copie -> $dest... "
            run_sudo mkdir -p "$dest" 2>/dev/null
            run_sudo cp "$TEMP_BACKUP" "$dest/"
            STATUS=$?
        fi
        
        if [ $STATUS -eq 0 ]; then
            [ -z "$IS_CRON" ] && echo -e "${GREEN}OK${NC}"
        else
            [ -z "$IS_CRON" ] && echo -e "${RED}ECHEC${NC}"
        fi
    done < "$LIST_RUN"
    
    run_sudo rm "$LIST_RUN" "$TEMP_BACKUP" 2>/dev/null
    [ -z "$IS_CRON" ] && pause
}

# --- NOUVELLE FONCTION RESTAURATION (TABLEAU + CONTENU) ---
perform_restore_wizard() {
    clear
    echo -e "${BLUE}################################################${NC}"
    echo -e "${BLUE}#           ASSISTANT DE RESTAURATION          #${NC}"
    echo -e "${BLUE}################################################${NC}"
    echo -e "${GREY}S√©lectionnez la source des sauvegardes.${NC}"
    echo ""
    
    declare -a SOURCES
    declare -a LABELS
    
    if [ "$BACKUP_DEFAULT_ENABLED" == "true" ]; then
        SOURCES+=("$BACKUP_DIR")
        LABELS+=("Local D√©faut")
    fi
    if [ -f "$BACKUP_LIST_FILE" ]; then
        while IFS= read -r dest; do
            [[ "$dest" == \#* ]] && continue
            if [[ "$dest" != "rclone:"* ]]; then
                SOURCES+=("$dest")
                LABELS+=("Local/Montage")
            fi
        done < "$BACKUP_LIST_FILE"
    fi
    
    if [ ${#SOURCES[@]} -eq 0 ]; then
        echo "Aucune source locale disponible."
        pause
        return
    fi
    
    # 1. TABLEAU DES SOURCES
    printf "%-4s %-20s %s\n" "ID" "TYPE" "CHEMIN"
    echo "----------------------------------------------------------------"
    
    for i in "${!SOURCES[@]}"; do
        printf "%-4s %-20s %s\n" "${CYAN}$((i+1))${NC}" "${LABELS[$i]}" "${SOURCES[$i]}"
    done
    echo "----------------------------------------------------------------"
    
    echo -e "$SEP_RED"
    echo -e "  ${RED}0.${NC} Annuler"
    echo -e "$SEP"
    read -p "  Votre choix > " s_idx
    
    if ! [[ "$s_idx" =~ ^[0-9]+$ ]] || [ "$s_idx" -lt 1 ] || [ "$s_idx" -gt ${#SOURCES[@]} ]; then
        return
    fi
    SRC_DIR="${SOURCES[$((s_idx-1))]}"
    
    echo -e "\n${YELLOW}Recherche d'archives dans $SRC_DIR...${NC}"
    
    # 2. Lister les fichiers pour le tableau
    mapfile -t FILES < <(ls -1t "$SRC_DIR"/*.tar.gz 2>/dev/null | head -10)
    if [ ${#FILES[@]} -eq 0 ]; then
        echo "Aucune archive trouv√©e."
        pause
        return
    fi

    printf "%-4s | %-12s | %-20s | %-10s | %s\n" "ID" "SOURCE" "CONTENU" "DATE" "HEURE"
    echo "------------------------------------------------------------------------"
    
    for i in "${!FILES[@]}"; do
        fname=$(basename "${FILES[$i]}")
        
        if [[ "$fname" =~ ([0-9]{8})_([0-9]{6}) ]]; then
            d="${BASH_REMATCH[1]}"
            t="${BASH_REMATCH[2]}"
            fdate="${d:6:2}/${d:4:2}/${d:0:4}"
            ftime="${t:0:2}:${t:2:2}"
        else
            fdate=$(date -r "${FILES[$i]}" "+%d/%m/%Y")
            ftime=$(date -r "${FILES[$i]}" "+%H:%M")
        fi

        ftype="Inconnu"
        [[ "$fname" == *"FULL"* ]] && ftype="Compl√®te"
        [[ "$fname" == *"CONFIGS"* ]] && ftype="Configs"
        [[ "$fname" == *"WEB_ONLY"* ]] && ftype="Web Seul"
        [[ "$fname" == *"SITE_"* ]] && ftype="Site Unique"

        printf "%-4s | %-12s | %-20s | %-10s | %s\n" "$((i+1))" "Local" "$ftype" "$fdate" "$ftime"
    done
    echo "------------------------------------------------------------------------"
    
    read -p "Choisir ID > " f_idx
    if ! [[ "$f_idx" =~ ^[0-9]+$ ]] || [ "$f_idx" -lt 1 ] || [ "$f_idx" -gt ${#FILES[@]} ]; then
        return
    fi
    SELECTED_FILE="${FILES[$((f_idx-1))]}"
    
    # --- LOGIQUE GRANULAIRE ---
    RESTORE_SCOPE="ALL"
    fname=$(basename "$SELECTED_FILE")
    
    if [[ "$fname" == *"FULL"* ]]; then
        echo -e "\n${CYAN}C'est une sauvegarde COMPL√àTE. Que voulez-vous restaurer ?${NC}"
        echo "1. ‚ö° TOUT RESTAURER (√âcrase tout)"
        echo "2. üìÇ Seulement les fichiers WEB (/var/www)"
        echo "3. ‚öôÔ∏è  Seulement les CONFIGS (Nginx/PHP)"
        read -p "> " r_choice
        case "$r_choice" in
            2) RESTORE_SCOPE="WEB" ;;
            3) RESTORE_SCOPE="CONF" ;;
            *) RESTORE_SCOPE="ALL" ;;
        esac
    fi

    echo -e "\n${RED}‚ö†Ô∏è  ATTENTION : RESTAURATION ($RESTORE_SCOPE) EN COURS...${NC}"
    echo "Archive : $fname"
    echo "Tapez 'RESTORE' pour confirmer :"
    read -p "> " confirm
    if [ "$confirm" != "RESTORE" ]; then
        echo "Annul√©."
        pause
        return
    fi
    
    if ask_sudo_gui; then
        echo "Extraction..."
        TAR_CMD="tar -xzf \"$SELECTED_FILE\" -C /"
        
        if [ "$RESTORE_SCOPE" == "WEB" ]; then
            TAR_CMD="$TAR_CMD var/www" 
        elif [ "$RESTORE_SCOPE" == "CONF" ]; then
            TAR_CMD="$TAR_CMD etc/nginx etc/php etc/nginx-manager"
        fi
        
        if run_sudo bash -c "$TAR_CMD"; then
            echo -e "${GREEN}Extraction r√©ussie.${NC}"
            echo "R√©tablissement des permissions..."
            run_sudo chown -R root:root /etc/nginx /etc/php 2>/dev/null
            run_sudo chown -R www-data:www-data /var/www 2>/dev/null
            echo "Red√©marrage des services..."
            run_sudo systemctl restart nginx
            run_sudo systemctl restart php*-fpm 2>/dev/null
            echo -e "${GREEN}‚úÖ Termin√©.${NC}"
        else
            echo -e "${RED}Erreur lors de l'extraction.${NC}"
        fi
        pause
    fi
}

setup_cron_job() {
    clear
    echo -e "${BLUE}=== CRON ROOT ===${NC}"
    EXISTING=$(sudo crontab -l 2>/dev/null | grep "nginx-manager-cron")
    if [ -n "$EXISTING" ]; then
        echo -e "√âtat : ${GREEN}ACTIF${NC}"
        echo "1. D√©sactiver"
    else
        echo -e "√âtat : ${YELLOW}INACTIF${NC}"
        echo "1. Activer (03h00)"
    fi
    read -p "> " c
    SCRIPT_PATH=$(realpath "$0")
    if [ "$c" == "1" ]; then
        if [ -n "$EXISTING" ]; then
            sudo crontab -l 2>/dev/null | grep -v "nginx-manager-cron" | sudo crontab -
            echo "D√©sactiv√©."
        else
            (sudo crontab -l 2>/dev/null; echo "0 3 * * * $SCRIPT_PATH --cron #nginx-manager-cron") | sudo crontab -
            echo "Activ√©."
        fi
        pause
    fi
}

backup_menu() {
    while true; do
        clear
        if sudo crontab -l 2>/dev/null | grep -q "nginx-manager-cron"; then
            ST_CRON="${GREEN}ACTIF (03h00)${NC}"
        else
            ST_CRON="${YELLOW}INACTIF${NC}"
        fi
        LAST_BKP="Aucune"
        if [ -d "$BACKUP_DIR" ]; then
            LATEST_FILE=$(ls -t "$BACKUP_DIR"/*.tar.gz 2>/dev/null | head -n1)
            if [ -n "$LATEST_FILE" ]; then
                LAST_BKP=$(date -r "$LATEST_FILE" "+%d/%m/%Y %H:%M")
                SIZE_BKP=$(du -h "$LATEST_FILE" | cut -f1)
                LAST_BKP="$LAST_BKP ($SIZE_BKP)"
            fi
        fi

        echo -e "${BLUE}################################################${NC}"
        echo -e "${BLUE}#           SAUVEGARDES & CLOUD                #${NC}"
        echo -e "${BLUE}################################################${NC}"
        printf "  ‚è∞ Planification Auto : %b\n" "$ST_CRON"
        printf "  üì¶ Derni√®re archive   : ${CYAN}%s${NC}\n" "$LAST_BKP"
        echo -e "$SEP"

        # --- TABLEAU AM√âLIOR√â ---
        printf "%-5s %-7s %-20s %-20s %s\n" "ID" "TYPE" "MONTAGE" "CIBLE" "√âTAT"
        echo "------------------------------------------------------------------------"
        
        # D√©faut
        if [ "$BACKUP_DEFAULT_ENABLED" == "true" ]; then ST="${GREEN}ACTIF${NC}"; else ST="${RED}OFF${NC}"; fi
        printf "%-5s %-7s %-20s %-20s %b\n" "1" "Local" "$BACKUP_DIR" "Disque Local" "$ST"

        idx=2
        if [ -f "$BACKUP_LIST_FILE" ]; then
            while IFS= read -r dest; do
                [ -z "$dest" ] && continue
                if [[ "$dest" == \#* ]]; then
                    ST="${RED}OFF${NC}"
                    clean="${dest#\#}"
                else
                    ST="${GREEN}ACTIF${NC}"
                    clean="$dest"
                fi
                
                TYPE="Local"
                TARGET="Disque Local"
                MOUNT="$clean"

                if [[ "$clean" == "rclone:"* ]]; then
                    TYPE="Cloud"
                    MOUNT="-"
                    TARGET="${clean#rclone:}"
                else
                    if [ -d "$clean" ] && command -v findmnt >/dev/null; then
                        SOURCE=$(findmnt -n -o SOURCE --target "$clean" 2>/dev/null)
                        FSTYPE=$(findmnt -n -o FSTYPE --target "$clean" 2>/dev/null)
                        
                        if [[ "$FSTYPE" == "cifs" ]]; then TYPE="SMB"; TARGET="$SOURCE"; fi
                        if [[ "$FSTYPE" == "nfs" || "$FSTYPE" == "nfs4" ]]; then TYPE="NFS"; TARGET="$SOURCE"; fi
                    fi
                fi
                
                # Truncate visuals
                if [ ${#MOUNT} -gt 20 ]; then MOUNT="...${MOUNT: -17}"; fi
                if [ ${#TARGET} -gt 20 ]; then TARGET="${TARGET:0:17}..."; fi
                
                printf "%-5s %-7s %-20s %-20s %b\n" "$idx" "$TYPE" "$MOUNT" "$TARGET" "$ST"
                ((idx++))
            done < "$BACKUP_LIST_FILE"
        fi
        echo "------------------------------------------------------------------------"
        echo ""

        echo -e " ${BOLD}${CYAN}üöÄ ACTIONS${NC}"
        echo -e "    ${GREEN}1.${NC} ‚ñ∂Ô∏è  Lancer une sauvegarde"
        echo -e "    ${GREEN}4.${NC} ‚ôªÔ∏è  Restaurer une sauvegarde (Wizard)"
        echo ""
        echo -e " ${BOLD}${CYAN}‚öôÔ∏è  CONFIGURATION${NC}"
        echo -e "    ${GREEN}2.${NC} üìÇ G√©rer les destinations (Ajout/Retrait/Activer)"
        echo -e "    ${GREEN}3.${NC} ‚è∞ Configurer la planification (Cron)"
        
        echo -e "$SEP_RED"
        echo -e "  ${RED}0.${NC} Retour au Menu Principal"
        echo -e "$SEP"

        read -r -p "  Votre choix > " c
        case "$c" in
            1) 
                if ask_sudo_gui; then
                   echo -e "\n${CYAN}QUE VOULEZ-VOUS SAUVEGARDER ?${NC}"
                   echo "1. ‚ö° TOUT (Web + Nginx + PHP + Manager) [Recommand√©]"
                   echo "2. ‚öôÔ∏è  Configurations seules (/etc/...)"
                   echo "3. üìÇ Donn√©es Web seules (/var/www)"
                   echo "4. üéØ Un site sp√©cifique (Vhost + Dossier racine)"
                   read -p "> " scope
                   case "$scope" in
                       1) perform_backup_routine "" "FULL" ;;
                       2) perform_backup_routine "" "CONFIGS" ;;
                       3) perform_backup_routine "" "WEB_ONLY" ;;
                       4) 
                          echo -e "\n${YELLOW}Sites disponibles (Enabled) :${NC}"
                          mapfile -t SITES_LIST < <(ls -1 "$SITES_ENAB")
                          if [ ${#SITES_LIST[@]} -eq 0 ]; then
                              echo "Aucun site activ√©."
                              pause
                          else
                              for i in "${!SITES_LIST[@]}"; do
                                  echo "$((i+1)). ${SITES_LIST[$i]}"
                              done
                              read -p "Num√©ro du site > " sn
                              if [[ "$sn" =~ ^[0-9]+$ ]] && [ "$sn" -ge 1 ] && [ "$sn" -le "${#SITES_LIST[@]}" ]; then
                                  SELECTED_FILE="${SITES_LIST[$((sn-1))]}"
                                  perform_backup_routine "" "SITE:$SELECTED_FILE"
                              else
                                  echo "Choix invalide."
                                  pause
                              fi
                          fi 
                          ;;
                       *) echo "Annul√©."; pause ;;
                   esac
               fi 
               ;;
            2) manage_backup_destinations ;;
            3) setup_cron_job ;;
            4) perform_restore_wizard ;;
            0) return ;;
            *) echo "Choix invalide"; sleep 1 ;;
        esac
    done
}

if [ "$1" == "--cron" ]; then
    [ -f "$CONFIG_FILE" ] && source "$CONFIG_FILE"
    if [ "$EUID" -ne 0 ]; then
        echo "Must be root"
        exit 1
    fi
    perform_backup_routine "cron" "FULL"
    exit 0
fi

# =======================================================
#  BOUCLE PRINCIPALE
# =======================================================

spawn_restricted_shell() {
    local TD="$1"
    local SN="$2"
    if [ ! -d "$TD" ]; then 
        if ask_sudo_gui; then 
            run_sudo mkdir -p "$TD"
        else 
            return
        fi
    fi
    clear
    echo -e "${GREEN}üîí JAIL ACTIV√âE : $SN${NC}"
    echo -e "${GREY}P√©rim√®tre restreint √† : $TD${NC}"
    echo -e "Tapez 'exit' pour sortir."
    local OH="$HOME"
    bash --rcfile <(echo "export HOME='$TD'; export PS1='\[\033[01;31m\](Jail:$SN) \[\033[01;34m\]\w \$ \[\033[00m\]'; export PATH='/usr/local/bin:/usr/bin:/bin'; check_path() { if [[ \"\$PWD\" != \"$TD\"* ]]; then echo -e \"\n\033[0;31m‚õî INTERDIT\033[0m\"; cd \"$TD\"; fi }; alias cd='check_path; cd'; export PROMPT_COMMAND='check_path'; cd \"$TD\"")
    export HOME="$OH"
    trap '' SIGINT SIGQUIT SIGTSTP
}

firewall_manager() {
    while true; do
        clear
        echo -e "${BLUE}################################################${NC}"
        echo -e "${BLUE}#                PARE-FEU (UFW)                #${NC}"
        echo -e "${BLUE}################################################${NC}"
        echo -e "${BOLD}--- √âTAT DES R√àGLES ---${NC}"
        if sudo -n true 2>/dev/null; then
            sudo ufw status numbered
        else
            echo -e "${GREY}(Authentification requise pour voir les r√®gles)${NC}"
        fi
        echo ""
        echo -e " ${BOLD}${CYAN}‚ö° ACTIONS${NC}"
        echo -e "    ${GREEN}1.${NC} ‚ûï Ouvrir un port (Allow)"
        echo -e "    ${RED}2.${NC} ‚ûñ Supprimer une r√®gle (Delete)"
        echo -e "    ${YELLOW}3.${NC} üîÑ Recharger les r√®gles (Reload)"
        echo -e "$SEP_RED"
        echo -e "  ${RED}0.${NC} Retour au Menu Principal"
        echo -e "$SEP"
        read -p "  Votre choix > " c
        case "$c" in
            1) 
                echo -e "\n${YELLOW}Port √† ouvrir (ex: 80/tcp) :${NC}"
                read -p "> " p
                [ -n "$p" ] && ask_sudo_gui && run_sudo ufw allow "$p"
                pause 
                ;;
            2) 
                echo -e "\n${YELLOW}Num√©ro de la r√®gle √† supprimer :${NC}"
                read -p "> " n
                [ -n "$n" ] && ask_sudo_gui && echo "y" | run_sudo ufw delete "$n"
                pause 
                ;;
            3) 
                ask_sudo_gui && run_sudo ufw reload
                pause 
                ;;
            0) return ;;
            *) echo "Choix invalide"; sleep 1 ;;
        esac
    done
}

while true; do
    clear
    ensure_requirements
    get_sys_info
    echo -e "${BLUE}################################################${NC}"
    echo -e "${BLUE}#           MANAGER SERVEUR WEB v2             #${NC}"
    echo -e "${BLUE}################################################${NC}"
    printf "  üñ•Ô∏è  %-21s | ‚ö° CPU : %s\n" "${CYAN}$OS_NAME${NC}" "$CPU_USAGE"
    printf "  üè† LAN: %-15s | üåç WAN: %s\n" "${YELLOW}$LOCAL_IP${NC}" "${YELLOW}$PUBLIC_IP${NC}"
    echo -e "$SEP"
    printf "  üß† RAM : %-15s | ‚ö° CPU : %s\n" "${CYAN}$RAM_USAGE${NC}" "${CYAN}$CPU_USAGE${NC}"
    printf "  üõ°Ô∏è  FW  : %-15s | üåê Sites Actifs : ${GREEN}%s${NC}\n" "$FW" "$SITES_COUNT"
    echo -e "$SEP"

    echo -e " ${BOLD}${CYAN}‚ö° GESTION DU SERVICE${NC}"
    echo -e "    ${GREEN}1.${NC} ‚ñ∂Ô∏è  D√©marrer le service"
    echo -e "    ${GREEN}2.${NC} ‚èπÔ∏è  Arr√™ter le service"
    echo -e "    ${GREEN}3.${NC} üîÑ Red√©marrer le service"
    echo -e "    ${GREEN}4.${NC} üìú Logs du service"
    echo ""
    echo -e " ${BOLD}${CYAN}üåê SITES & D√âPLOIEMENT${NC}"
    echo -e "    ${GREEN}5.${NC} üåê Gestion des Sites Web (Dashboard)"
    echo -e "    ${GREEN}6.${NC} ‚öôÔ∏è  Configuration (Infomaniak / Zoraxy)"
    echo ""
    echo -e " ${BOLD}${CYAN}üõ°Ô∏è  S√âCURIT√â & MAINTENANCE${NC}"
    echo -e "    ${GREEN}7.${NC} üß± Pare-feu (UFW)"
    echo -e "    ${GREEN}8.${NC} üîí Shell Restreint (Jail)"
    echo -e "    ${GREEN}9.${NC} üíæ Sauvegardes & Cloud"
    echo -e "    ${GREEN}10.${NC}üöÄ Mises √† jour Syst√®me"
    echo -e "$SEP_RED"
    echo -e " ${BOLD}${RED}üíÄ ZONES SYST√àME${NC}"
    echo -e "    ${RED}11.${NC}üîå √âteindre le serveur"
    echo -e "    ${RED}12.${NC}‚ôªÔ∏è  Red√©marrer le serveur"
    echo -e "$SEP"
    echo -e "  [${RED}exit${NC}] üö™ Quitter"
    echo -e "$SEP"

    read -r -p "  Votre choix > " ch
    case "$ch" in
        1) ask_sudo_gui && run_sudo systemctl start nginx; pause ;;
        2) ask_sudo_gui && run_sudo systemctl stop nginx; pause ;;
        3) ask_sudo_gui && run_sudo systemctl restart nginx; pause ;;
        4) run_sudo tail -f "$LOG_ERROR" ;;
        5) manage_nginx_sites_menu ;;
        6) settings_menu ;;
        7) firewall_manager ;;
        8)
           clear
           echo -e "${BLUE}################################################${NC}"
           echo -e "${BLUE}#        üîí ACC√àS SHELL RESTREINT (JAIL)       #${NC}"
           echo -e "${BLUE}################################################${NC}"
           echo -e "${GREY}Ouvre un terminal isol√© dans un dossier sp√©cifique.${NC}"
           echo -e "${GREY}Commandes limit√©es. Tapez 'exit' pour sortir.${NC}"
           echo -e "$SEP"
           echo -e "  ${GREEN}1.${NC} üìÇ Dossier WEB   ${GREY}($DIR_WEB)${NC}"
           echo -e "  ${GREEN}2.${NC} ‚öôÔ∏è  Config NGINX  ${GREY}($NGINX_HOME)${NC}"
           echo -e "  ${GREEN}3.${NC} üêò Config PHP    ${GREY}($DIR_PHP)${NC}"
           echo -e "$SEP_RED"
           echo -e "  ${RED}0.${NC} Retour"
           echo -e "$SEP"
           read -p "  Cible > " j
           case "$j" in
               1) spawn_restricted_shell "$DIR_WEB" "WEB" ;;
               2) spawn_restricted_shell "$NGINX_HOME" "NGINX" ;;
               3) spawn_restricted_shell "$DIR_PHP" "PHP" ;;
               0) ;;
               *) echo "Choix invalide"; sleep 1 ;;
           esac
           ;;
        9) backup_menu ;;
        10) ask_sudo_gui && sudo apt update && sudo apt upgrade -y; pause ;;
        11) ask_sudo_gui && sudo poweroff ;;
        12) ask_sudo_gui && sudo reboot ;;
        exit|q) exit 0 ;;
        *) echo "Choix invalide"; sleep 1 ;;
    esac
done
