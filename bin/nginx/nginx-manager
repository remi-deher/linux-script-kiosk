#!/bin/bash

# =======================================================
#  MANAGER SERVEUR WEB - VERSION FINALE
# =======================================================

# --- CONFIGURATION ---
DIR_WEB="/var/www"
DIR_NGINX="/etc/nginx"
DIR_PHP="/etc/php"
BACKUP_DIR="/var/backups/nginx-manager"
LOG_ACCESS="/var/log/nginx/access.log"
LOG_ERROR="/var/log/nginx/error.log"
SERVICE_NAME="nginx"
SITES_AVAIL="$DIR_NGINX/sites-available"
SITES_ENAB="$DIR_NGINX/sites-enabled"

# Cache & Config
PUBLIC_IP_CACHE="/tmp/nginx_public_ip"
CMD_NGINX="/usr/sbin/nginx"
CMD_UFW="/usr/sbin/ufw"

# --- SÃ‰CURITÃ‰ & COULEURS ---
trap '' SIGINT SIGQUIT SIGTSTP
BLUE=$'\033[0;34m'; GREEN=$'\033[0;32m'; RED=$'\033[0;31m'; YELLOW=$'\033[1;33m'; CYAN=$'\033[0;36m'; GREY=$'\033[1;30m'; NC=$'\033[0m'; BOLD=$'\033[1m'

# --- 1. GESTION SUDO ---
ask_sudo_gui() {
    if sudo -n true 2>/dev/null; then return 0; fi
    echo -e "\n${YELLOW}ðŸ”’ Authentification requise${NC}"
    read -s -p "Mot de passe : " user_pass; echo ""
    echo "$user_pass" | sudo -S -v 2>/dev/null
    if [ $? -eq 0 ]; then return 0; else echo -e "${RED}âŒ Incorrect.${NC}"; pause; return 1; fi
}
run_sudo() {
    if sudo -n "$@" 2>/dev/null; then return 0; fi
    if sudo -n true 2>/dev/null; then sudo "$@"; return $?; fi
    if ! ask_sudo_gui; then return 1; fi
    sudo "$@"
}
run_sudo_silent() { if sudo -n "$@" 2>/dev/null; then return 0; fi; return 1; }
pause() { echo ""; read -p "Appuyez sur EntrÃ©e pour continuer..."; }

ensure_installed() {
    local cmd="$1"; local pkg="$2"
    if ! command -v "$cmd" &> /dev/null; then
        echo -e "\n${YELLOW}âš ï¸  Outil requis manquant : '$cmd'${NC}"
        read -p "Installer '$pkg' ? (o/n) " i
        if [[ "$i" == "o" ]]; then
            if ask_sudo_gui; then run_sudo apt-get update -qq; run_sudo apt-get install -y "$pkg"; fi
        else return 1; fi
    fi
    return 0
}

server_power_action() {
    local a="$1"; local c="$2"; local cw=$(echo "$a" | tr '[:upper:]' '[:lower:]' | sed 's/Ã©/e/g')
    echo -e "\n${RED}${BOLD}âš ï¸  ATTENTION : $a LE SYSTÃˆME${NC}"; read -p "Tapez '$cw' pour exÃ©cuter : " i
    if [ "$i" == "$cw" ]; then run_sudo $c; exit 0; else echo "AnnulÃ©."; pause; fi
}

get_sys_info() {
    LOCAL_IP=$(hostname -I | awk '{print $1}')
    if [ -f "$PUBLIC_IP_CACHE" ] && [ $(( $(date +%s) - $(stat -c %Y "$PUBLIC_IP_CACHE") )) -lt 3600 ]; then PUBLIC_IP=$(cat "$PUBLIC_IP_CACHE"); else
        PUBLIC_IP=$(curl -s -4 -m 3 https://icanhazip.com 2>/dev/null); [[ "$PUBLIC_IP" =~ ^[0-9.]+$ ]] && echo "$PUBLIC_IP" > "$PUBLIC_IP_CACHE" || PUBLIC_IP="N/A"
    fi
    OS_NAME=$(grep -oP 'PRETTY_NAME="\K[^"]+' /etc/os-release 2>/dev/null | cut -c1-20); [ -z "$OS_NAME" ] && OS_NAME="Linux"
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1"%"}' 2>/dev/null); [ -z "$CPU_USAGE" ] && CPU_USAGE="N/A"
    RAM_USAGE=$(free -h | awk '/^Mem:/ {print $3 "/" $2}')
    SYS_UPTIME=$(uptime -p | sed 's/up //;s/ hours/h/;s/ minutes/m/')

    # --- CORRECTION VERSION NGINX ---
    # MÃ©thode 1 : Execution directe (stderr redirigÃ© vers stdout)
    APP_VER=$($CMD_NGINX -v 2>&1 | awk -F/ '{print $2}')

    # MÃ©thode 2 : Fallback dpkg si la commande Ã©choue
    if [ -z "$APP_VER" ]; then
        APP_VER=$(dpkg -s nginx 2>/dev/null | grep "Version" | awk '{print $2}' | cut -d: -f2 | cut -d- -f1)
    fi

    [ -z "$APP_VER" ] && APP_VER="Inconnue"
}

# --- 2. GESTION VHOSTS ---

# Variable globale
declare -a VHOST_FILES

refresh_vhost_list() {
    VHOST_FILES=()
    shopt -s nullglob; local files=("$SITES_AVAIL"/*); shopt -u nullglob

    echo -e "${BLUE}=== LISTE DES VHOSTS ===${NC}"
    printf "${GREY}%-3s %-25s %-10s %-30s %-10s${NC}\n" "ID" "DOMAINE" "PORT" "RACINE" "Ã‰TAT"
    echo "--------------------------------------------------------------------------------"

    if [ ${#files[@]} -eq 0 ]; then
        echo "   (Aucun site configurÃ©)"
    else
        local i=1
        for f in "${files[@]}"; do
            VHOST_FILES+=("$f")
            bn=$(basename "$f"); bn_noext="${bn%.*}"

            # Ã‰tat
            if ls "$SITES_ENAB/$bn"* 1> /dev/null 2>&1; then st="${GREEN}â— ON${NC}"; else st="${RED}â— OFF${NC}"; fi

            # Lecture contenu (OptimisÃ©e)
            if [ -r "$f" ]; then content=$(cat "$f" 2>/dev/null); else content=$(sudo cat "$f" 2>/dev/null); fi

            # Parsing
            port=$(echo "$content" | grep -E "^\s*listen" | grep -oE "[0-9]+" | head -n1)
            [ -z "$port" ] && port="-"
            root=$(echo "$content" | grep -E "^\s*root\s+" | awk '{print $2}' | tr -d ';')
            [ -z "$root" ] && root="-"

            printf "%-3s %-25s %-10s %-30s %b\n" "$i" "${bn_noext:0:24}" "$port" "${root:0:29}" "$st"
            ((i++))
        done
    fi
    echo "--------------------------------------------------------------------------------"
}

create_vhost_wizard() {
    echo -e "\n${GREEN}âž• AJOUTER UN NOUVEAU SITE${NC}"
    read -p "Nom de domaine (ex: site.lan) : " domain
    [ -z "$domain" ] && return
    read -p "Port d'Ã©coute (ex: 80) : " port
    port=${port:-80}
    read -p "Dossier racine (dÃ©faut: $DIR_WEB/$domain) : " docroot
    docroot=${docroot:-"$DIR_WEB/$domain"}

    if ! ask_sudo_gui; then return; fi

    # CrÃ©ation dossier
    if [ ! -d "$docroot" ]; then
        run_sudo mkdir -p "$docroot"
        echo "<h1>Site $domain</h1>" | run_sudo tee "$docroot/index.html" >/dev/null
        run_sudo chown -R www-data:www-data "$docroot"
        run_sudo chmod -R 755 "$docroot"
        echo "Dossier $docroot crÃ©Ã©."
    fi

    # Config Nginx
    conf="$SITES_AVAIL/$domain.conf"
    run_sudo bash -c "cat > '$conf' <<EOF
server {
    listen $port;
    server_name $domain;
    root $docroot;
    index index.html index.htm index.php;
    access_log /var/log/nginx/${domain}_access.log;
    error_log /var/log/nginx/${domain}_error.log;
    location / { try_files \$uri \$uri/ =404; }
}
EOF"

    # Activation
    run_sudo ln -sf "$conf" "$SITES_ENAB/$domain.conf"
    run_sudo ufw allow "$port/tcp" >/dev/null

    if run_sudo nginx -t; then
        run_sudo systemctl reload nginx
        echo -e "${GREEN}âœ… Site actif sur le port $port !${NC}"
    else
        echo -e "${RED}âŒ Erreur config Nginx.${NC}"
        run_sudo rm "$SITES_ENAB/$domain.conf"
    fi
    pause
}

action_toggle_vhost() {
    read -p "NumÃ©ro du site Ã  basculer (ON/OFF) : " sel
    if [[ "$sel" =~ ^[0-9]+$ ]] && [ "$sel" -ge 1 ] && [ "$sel" -le "${#VHOST_FILES[@]}" ]; then
        f="${VHOST_FILES[$((sel-1))]}"
        bn=$(basename "$f")
        if ! ask_sudo_gui; then return; fi

        target=$(find "$SITES_ENAB" -name "$bn*")
        if [ -n "$target" ]; then
            run_sudo rm "$target"; echo -e "${RED}Site dÃ©sactivÃ©.${NC}"
        else
            run_sudo ln -sf "$f" "$SITES_ENAB/$bn"; echo -e "${GREEN}Site activÃ©.${NC}"
        fi
        run_sudo systemctl reload nginx; pause
    else
        echo "NumÃ©ro invalide."; sleep 1
    fi
}

action_delete_vhost() {
    read -p "NumÃ©ro du site Ã  SUPPRIMER : " sel
    if [[ "$sel" =~ ^[0-9]+$ ]] && [ "$sel" -ge 1 ] && [ "$sel" -le "${#VHOST_FILES[@]}" ]; then
        f="${VHOST_FILES[$((sel-1))]}"
        bn=$(basename "$f")
        echo -e "${RED}ATTENTION : Suppression de $bn${NC}"
        read -p "Confirmer ? (o/n) : " c
        if [ "$c" == "o" ] && ask_sudo_gui; then
            target=$(find "$SITES_ENAB" -name "$bn*")
            [ -n "$target" ] && run_sudo rm "$target"
            run_sudo mkdir -p "$BACKUP_DIR"
            run_sudo cp "$f" "$BACKUP_DIR/deleted_$bn.conf"
            run_sudo rm "$f"
            run_sudo systemctl reload nginx
            echo "SupprimÃ©."; pause
        fi
    fi
}

action_edit_vhost() {
    read -p "NumÃ©ro du site Ã  modifier : " sel
    if [[ "$sel" =~ ^[0-9]+$ ]] && [ "$sel" -ge 1 ] && [ "$sel" -le "${#VHOST_FILES[@]}" ]; then
        f="${VHOST_FILES[$((sel-1))]}"
        if ask_sudo_gui; then
            run_sudo nano "$f"
            echo "VÃ©rification..."
            if run_sudo nginx -t; then run_sudo systemctl reload nginx; echo "Config rechargÃ©e."; else echo "${RED}Erreur syntaxe!${NC}"; fi
            pause
        fi
    fi
}

manage_nginx_sites_menu() {
    if [ ! -r "$SITES_AVAIL" ]; then ask_sudo_gui; fi
    while true; do
        clear
        refresh_vhost_list
        echo -e "${BOLD}--- ACTIONS ---${NC}"
        echo -e "  ${GREEN}1.${NC} âž• Ajouter un site"
        echo -e "  ${YELLOW}2.${NC} â¯ï¸  Activer / DÃ©sactiver"
        echo -e "  ${CYAN}3.${NC} ðŸ“ Modifier"
        echo -e "  ${RED}4.${NC} ðŸ—‘ï¸  Supprimer"
        echo -e "  ${RED}r.${NC} Retour"
        read -r -p "> " ch
        case "$ch" in
            1) create_vhost_wizard ;;
            2) action_toggle_vhost ;;
            3) action_edit_vhost ;;
            4) action_delete_vhost ;;
            r) break ;;
            *) echo "Invalide"; sleep 0.5 ;;
        esac
    done
}

# --- 3. AUTRES FONCTIONS ---

firewall_manager() {
    while true; do
        clear
        if run_sudo_silent ufw status | grep -q "active"; then ST="${GREEN}ACTIF${NC}"; else ST="${RED}INACTIF${NC}"; fi
        echo -e "${BLUE}=== GESTION PARE-FEU ($ST) ===${NC}"
        mapfile -t RULES < <(run_sudo ufw status numbered | grep "^\[")
        if [ ${#RULES[@]} -eq 0 ]; then echo "   (Aucune rÃ¨gle)"; else
            for line in "${RULES[@]}"; do echo "$line" | sed "s/ALLOW/${GREEN}ALLOW${NC}/" | sed "s/DENY/${RED}DENY${NC}/"; done
        fi
        echo "------------------------------------------------"
        echo -e "1. Ouvrir Port | 2. Supprimer (Liste) | 3. ON/OFF | r. Retour"
        read -r -p "> " c
        case "$c" in
            1) read -p "Port: " p; [ -n "$p" ] && if ask_sudo_gui; then run_sudo ufw allow "$p"; pause; fi ;;
            2) echo "Pour supprimer : sudo ufw delete <numÃ©ro>"; pause ;;
            3) if [[ "$ST" == *"ACTIF"* ]]; then run_sudo ufw disable; else run_sudo ufw enable; fi; pause ;;
            r) return ;;
        esac
    done
}

deploy_from_github() {
    clear; echo -e "${BLUE}--- DÃ‰PLOIEMENT GITHUB ---${NC}"
    ensure_installed "git" "git" || return
    read -p "URL dÃ©pÃ´t : " repo_url; [ -z "$repo_url" ] && return
    echo -e "Dest: ${CYAN}$DIR_WEB/<dossier>${NC}"; read -p "Nom dossier : " folder_name; [ -z "$folder_name" ] && return
    TARGET="$DIR_WEB/$folder_name"
    if [ -d "$TARGET" ]; then
        read -p "Dossier existe. Supprimer ? (o/n) " d; [[ "$d" == "o" ]] && run_sudo rm -rf "$TARGET" || return
    fi
    if run_sudo git clone "$repo_url" "$TARGET"; then echo "${GREEN}ClonÃ©.${NC}"; else echo "${RED}Erreur.${NC}"; pause; return; fi
    if [ -f "$TARGET/composer.json" ]; then
        read -p "Installer composer ? (o/n) " dc; [[ "$dc" == "o" ]] && ensure_installed "composer" "composer" && run_sudo bash -c "cd $TARGET && export COMPOSER_ALLOW_SUPERUSER=1; composer install --no-interaction --optimize-autoloader"
    fi
    run_sudo chown -R www-data:www-data "$TARGET"; run_sudo chmod -R 755 "$TARGET"
    read -p "CrÃ©er Vhost ? (o/n) " cv; [[ "$cv" == "o" ]] && create_vhost_wizard
    pause
}

multi_select_backup() {
    local T="$1"; local L="$2"; [ ! -d "$T" ] && return
    run_sudo mkdir -p "$BACKUP_DIR"; shopt -s nullglob; local I=("$T"/*); shopt -u nullglob
    [ ${#I[@]} -eq 0 ] && return
    declare -A S; for i in "${!I[@]}"; do S[$i]=0; done
    while true; do
        clear; echo -e "${BLUE}BACKUP : $L${NC}"
        for i in "${!I[@]}"; do [ "${S[$i]}" -eq 1 ] && M="${GREEN}[x]${NC}" || M="${RED}[ ]${NC}"; printf "  %s %2d. %s\n" "$M" $((i+1)) "$(basename "${I[$i]}")"; done
        echo "  G. Go | T. Tout | N. Rien | r. Retour"; read -r -p "> " c
        [[ "$c" == "r" ]] && break; [[ "$c" =~ [Tt] ]] && { for i in "${!I[@]}"; do S[$i]=1; done; continue; }; [[ "$c" =~ [Nn] ]] && { for i in "${!I[@]}"; do S[$i]=0; done; continue; }
        if [[ "$c" =~ [Gg] ]]; then
            F=""; H=0; for i in "${!I[@]}"; do [ "${S[$i]}" -eq 1 ] && { F="$F $(basename "${I[$i]}")"; H=1; }; done
            [ $H -eq 0 ] && continue
            D=$(date +%Y%m%d_%H%M%S); A="backup_${L}_$D.tar.gz"
            echo "Zip..."; run_sudo bash -c "cd $T && tar -czf $BACKUP_DIR/$A $F"; echo "OK: $A"; pause; break
        fi
        [[ "$c" =~ ^[0-9]+$ ]] && [ "$c" -ge 1 ] && [ "$c" -le ${#I[@]} ] && { idx=$((c-1)); [ "${S[$idx]}" -eq 0 ] && S[$idx]=1 || S[$idx]=0; }
    done
}

backup_menu() {
    while true; do
        clear; echo -e "${BLUE}=== ðŸ’¾ SAUVEGARDES ===${NC}"; echo -e "  1. ComplÃ¨te | 2. Config Nginx | 3. Data Web | 4. Vhosts | 5. Voir | 6. Restaurer Vhost | r. Retour"
        read -r -p "> " c; D=$(date +%Y%m%d_%H%M%S)
        case "$c" in
            1) if ask_sudo_gui; then run_sudo mkdir -p "$BACKUP_DIR"; run_sudo tar -czf "$BACKUP_DIR/FULL_SERVER_$D.tar.gz" "$DIR_NGINX" "$DIR_WEB"; echo "OK"; pause; fi ;;
            2) if ask_sudo_gui; then run_sudo mkdir -p "$BACKUP_DIR"; run_sudo tar -czf "$BACKUP_DIR/NGINX_CONF_$D.tar.gz" "$DIR_NGINX"; echo "OK"; pause; fi ;;
            3) multi_select_backup "$DIR_WEB" "WebData" ;;
            4) multi_select_backup "$SITES_AVAIL" "Vhosts" ;;
            5) ls -lh "$BACKUP_DIR" 2>/dev/null; pause ;;
            6) shopt -s nullglob; files=("$BACKUP_DIR"/deleted_vhost_*.tar.gz); shopt -u nullglob; if [ ${#files[@]} -eq 0 ]; then echo "Rien."; pause; continue; fi
               for i in "${!files[@]}"; do echo "$((i+1)). $(basename "${files[$i]}")"; done; read -p "Num > " n
               if [[ "$n" =~ ^[0-9]+$ ]]; then sel="${files[$((n-1))]}"; run_sudo tar -xzf "$sel" -C "$SITES_AVAIL" && echo "RestaurÃ©" && pause; fi ;;
            r) break ;;
        esac
    done
}

logs_menu() {
    while true; do
        clear; echo "1. Access | 2. Error | r. Retour"; read -r -p "> " c
        case "$c" in 1) run_sudo tail -f "$LOG_ACCESS" ;; 2) run_sudo tail -f "$LOG_ERROR" ;; r) return ;; esac
    done
}

menu_system_update() {
    if ask_sudo_gui; then sudo apt update && sudo apt upgrade -y; pause; fi
}

open_user_shell() { if ! ask_sudo_gui; then return; fi; echo -e "\n${GREEN}ðŸ”“ AccÃ¨s autorisÃ©.${NC}"; trap - SIGINT SIGQUIT SIGTSTP; export SKIP_KIOSK_MENU=1; bash --login; unset SKIP_KIOSK_MENU; trap '' SIGINT SIGQUIT SIGTSTP; }
spawn_restricted_shell() {
    local TD="$1"; local SN="$2"; [ ! -d "$TD" ] && run_sudo mkdir -p "$TD"
    echo -e "\n${GREEN}ðŸ”’ JAIL $SN${NC}"; local OH="$HOME"
    bash --rcfile <(echo "export HOME='$TD'; export PS1='(Restreint:$SN) \[\033[01;34m\]\w\[\033[00m\]\\$ '; check_path() { if [[ \"\$PWD\" != \"$TD\"* ]]; then echo -e \"\n${RED}â›” Interdit.${NC}\"; cd \"$TD\"; fi; }; alias cd='check_path; cd'; export PROMPT_COMMAND='check_path'; export PATH='/usr/local/bin:/usr/bin:/bin'")
    export HOME="$OH"; trap '' SIGINT SIGQUIT SIGTSTP;
}

# --- 4. BOUCLE PRINCIPALE ---
while true; do
    clear; get_sys_info

    # STATUS CHECK DANS LA BOUCLE
    if systemctl is-active --quiet $SERVICE_NAME; then SX="${GREEN}â— ON${NC}"; else SX="${RED}â— OFF${NC}"; fi
    if run_sudo_silent $CMD_UFW status 2>/dev/null | grep -q "Status: active"; then FW="${GREEN}â— ACTIF${NC}"; else FW="${RED}â— INACTIF${NC}"; fi

    echo -e "${BLUE}$HEADER_LINE${NC}"
    echo -e "${BLUE}#         MANAGER SERVEUR WEB             #${NC}"
    echo -e "${BLUE}$HEADER_LINE${NC}"
    printf "  ðŸ–¥ï¸  %-20s | â±ï¸  %s\n" "${CYAN}$OS_NAME${NC}" "${GREY}$SYS_UPTIME${NC}"
    printf "  ðŸ§  CPU: %-14s | ðŸ’¾ RAM: %s\n" "${YELLOW}$CPU_USAGE${NC}" "${YELLOW}$RAM_USAGE${NC}"
    printf "  ðŸ  LAN: %-14s | ðŸŒ WAN: %s\n" "${YELLOW}$LOCAL_IP${NC}" "${YELLOW}$PUBLIC_IP${NC}"
    echo "---------------------------------------------"
    printf "  ðŸ”Œ Service : %-11b | ðŸ›¡ï¸  Pare-feu : %s\n" "$SX" "$FW"
    printf "  â„¹ï¸  Version : %-11s | âš“ Ports    : %s/%s\n" "${CYAN}$APP_VER${NC}" "${YELLOW}80${NC}" "${YELLOW}443${NC}"

    echo "---------------------------------------------"
    echo -e "${BOLD}--- SECTION SERVICE ---${NC}"
    echo -e "  ${GREEN}1.${NC} â–¶ï¸  DÃ©marrer le service"
    echo -e "  ${GREEN}2.${NC} â¹ï¸  ArrÃªter le service"
    echo -e "  ${GREEN}3.${NC} ðŸ”„ RedÃ©marrer le service"
    echo -e "  ${GREEN}4.${NC} ðŸ“œ Logs du service"
    echo ""
    echo -e "${BOLD}--- SECTION GESTION ---${NC}"
    echo -e "  ${GREEN}5.${NC} ðŸŒ Sites Web (VHosts)"
    echo -e "  ${GREEN}6.${NC} ðŸ§± Pare-feu (UFW)"
    echo -e "  ${GREEN}7.${NC} ðŸ“‚ Explorateur Fichiers (Jails)"
    echo -e "  ${GREEN}8.${NC} ðŸ’¾ Sauvegardes"
    echo -e "  ${GREEN}9.${NC} ðŸ™ DÃ©ployer via GitHub"
    echo ""
    echo -e "${BOLD}--- SECTION SYSTÃˆME ---${NC}"
    echo -e "  ${GREEN}10.${NC}ðŸš€ Mises Ã  jour SystÃ¨me"
    echo -e "  ${RED}11.${NC}ðŸ”Œ Ã‰teindre le serveur"
    echo -e "  ${RED}12.${NC}â™»ï¸  RedÃ©marrer le serveur"
    echo "---------------------------------------------"
    echo -e "  [${YELLOW}admin${NC}] ðŸ’» Console Admin"
    echo -e "  [${RED}exit${NC}]  ðŸšª Quitter"
    echo "---------------------------------------------"
    read -r -p "Votre choix > " ch

    case "$ch" in
        1) if ask_sudo_gui; then run_sudo systemctl start nginx; echo "OK"; pause; fi ;;
        2) if ask_sudo_gui; then run_sudo systemctl stop nginx; echo "OK"; pause; fi ;;
        3) if ask_sudo_gui; then run_sudo systemctl restart nginx; echo "OK"; pause; fi ;;
        4) logs_menu ;;
        5) manage_nginx_sites_menu ;;
        6) firewall_manager ;;
        7) echo "1. WEB | 2. NGINX | 3. PHP"; read -p "> " j; [ "$j" == "1" ] && spawn_restricted_shell "$DIR_WEB" "WEB"; [ "$j" == "2" ] && spawn_restricted_shell "$DIR_NGINX" "NGINX"; [ "$j" == "3" ] && spawn_restricted_shell "$DIR_PHP" "PHP" ;;
        8) backup_menu ;;
        9) deploy_from_github ;;
        10) menu_system_update ;;
        11) server_power_action "Ã‰TEINDRE" "poweroff" ;;
        12) server_power_action "REDÃ‰MARRER" "reboot" ;;
        admin) open_user_shell ;;
        exit) kill -9 $PPID 2>/dev/null; exit 0 ;;
        *) echo "Choix invalide"; sleep 1 ;;
    esac
done
