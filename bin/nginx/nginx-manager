#!/bin/bash
# ================================
#  MANAGER SERVEUR WEB
# ================================

# --- CONFIGURATION UTILISATEUR ---
REGISTAR_TOKEN=""
REGISTAR_DOMAIN_ID=""
ZORAXY_IP=""
ZORAXY_PORT="8000"

# --- CONFIGURATION SYSTEME ---
DIR_WEB="/var/www"
NGINX_HOME="/etc/nginx"
SITES_AVAIL="$NGINX_HOME/sites-available"
SITES_ENAB="$NGINX_HOME/sites-enabled"
BACKUP_DIR="/var/backups/nginx-manager"
LOG_ACCESS="/var/log/nginx/access.log"
LOG_ERROR="/var/log/nginx/error.log"

# --- CONFIGURATION ZORAXY (LAN) ---
ZORAXY_API_URL="http://$ZORAXY_IP:$ZORAXY_PORT"
COOKIE_FILE="/tmp/zoraxy_cookie_manager.txt"
ZORAXY_SERVICE_NAME="zoraxy"
ZORAXY_ACME_DIR="/etc/zoraxy/conf/certs/acme"

# --- CACHE & UTILITAIRES ---
PUBLIC_IP_CACHE="/tmp/nginx_public_ip"
CMD_NGINX="/usr/sbin/nginx"
CMD_UFW="/usr/sbin/ufw"

# --- S√âCURIT√â & COULEURS ---
trap '' SIGINT SIGQUIT SIGTSTP
BLUE=$'\033[0;34m'
GREEN=$'\033[0;32m'
RED=$'\033[0;31m'
YELLOW=$'\033[1;33m'
CYAN=$'\033[0;36m'
GREY=$'\033[1;30m'
NC=$'\033[0m'
BOLD=$'\033[1m'

# =======================================================
#  1. FONCTIONS SYST√àME DE BASE
# =======================================================

ask_sudo_gui() {
    if sudo -n true 2>/dev/null; then return 0; fi
    echo -e "\n${YELLOW}üîí Authentification requise${NC}"
    read -s -p "Mot de passe : " user_pass
    echo ""
    echo "$user_pass" | sudo -S -v 2>/dev/null
    if [ $? -eq 0 ]; then return 0; else echo -e "${RED}‚ùå Incorrect.${NC}"; pause; return 1; fi
}

run_sudo() {
    if sudo -n true 2>/dev/null; then sudo "$@"; return $?; fi
    if ! ask_sudo_gui; then return 1; fi
    sudo "$@"
}

run_sudo_silent() {
    sudo -n "$@" 2>/dev/null
}

pause() {
    echo ""
    read -p "Appuyez sur Entr√©e pour continuer..."
}

ensure_requirements() {
    if ! command -v jq &> /dev/null; then echo -e "${RED}Erreur: 'jq' requis.${NC}"; exit 1; fi
    if ! command -v curl &> /dev/null; then echo -e "${RED}Erreur: 'curl' requis.${NC}"; exit 1; fi
    if ! command -v git &> /dev/null; then echo -e "${RED}Erreur: 'git' requis.${NC}"; exit 1; fi
}

get_sys_info() {
    LOCAL_IP=$(hostname -I | awk '{print $1}')
    if [ -f "$PUBLIC_IP_CACHE" ] && [ $(( $(date +%s) - $(stat -c %Y "$PUBLIC_IP_CACHE") )) -lt 3600 ]; then
        PUBLIC_IP=$(cat "$PUBLIC_IP_CACHE")
    else
        PUBLIC_IP=$(curl -s -4 -m 3 https://icanhazip.com 2>/dev/null)
        [[ "$PUBLIC_IP" =~ ^[0-9.]+$ ]] && echo "$PUBLIC_IP" > "$PUBLIC_IP_CACHE" || PUBLIC_IP="N/A"
    fi
    OS_NAME=$(grep -oP 'PRETTY_NAME="\K[^"]+' /etc/os-release 2>/dev/null | cut -c1-20)
    [ -z "$OS_NAME" ] && OS_NAME="Linux"
    APP_VER=$($CMD_NGINX -v 2>&1 | awk -F/ '{print $2}')
    
    if systemctl is-active --quiet nginx; then SX="${GREEN}‚óè ON${NC}"; else SX="${RED}‚óè OFF${NC}"; fi
    if run_sudo_silent $CMD_UFW status 2>/dev/null | grep -q "active"; then FW="${GREEN}‚óè ACTIF${NC}"; else FW="${RED}‚óè INACTIF${NC}"; fi
}

normalize_domain_input() {
    local input="$1"
    local base="$REGISTAR_DOMAIN_ID"
    input="${input%.}" 
    if [[ "$input" == *"$base" ]]; then
        VAL_FQDN="$input"
        VAL_SUB="${input%.$base}"
    else
        VAL_SUB="$input"
        VAL_FQDN="${input}.${base}"
    fi
}

check_port_free() {
    local port="$1"
    if sudo ss -tuln | grep -q ":$port "; then return 1; fi
    return 0
}

# =======================================================
#  2. MODULE API ZORAXY (AUTO-HEALING)
# =======================================================

check_zoraxy_health() {
    if curl -s -m 1 "$ZORAXY_API_URL/api/auth/username" >/dev/null; then return 0; fi
    echo -e "\n${RED}‚ö†Ô∏è  ALERTE : Zoraxy ne r√©pond plus !${NC}"
    echo -e "${YELLOW}üîÑ Red√©marrage automatique du service...${NC}"
    run_sudo systemctl restart "$ZORAXY_SERVICE_NAME"
    for i in {1..15}; do
        if curl -s -m 1 "$ZORAXY_API_URL/api/auth/username" >/dev/null; then echo -e " ${GREEN}OK !${NC}"; return 0; fi
        echo -n "."; sleep 1
    done
    echo -e "\n${RED}‚ùå √âchec critique Zoraxy.${NC}"; return 1
}

check_zoraxy_auth() {
    [ ! -f "$COOKIE_FILE" ] && return 1
    CHECK=$(curl -s -m 2 -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/api/auth/username")
    [[ "$CHECK" == *\"* ]] && [[ "$CHECK" != *"error"* ]] && return 0
    return 1
}

ensure_zoraxy_auth() {
    if ! check_zoraxy_health; then return 1; fi
    if check_zoraxy_auth; then return 0; fi
    HOMEPAGE=$(curl -s -L -k -c "$COOKIE_FILE" -b "$COOKIE_FILE" "$ZORAXY_API_URL/" --max-time 2)
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    echo -e "\n${CYAN}üîê Authentification Zoraxy requise${NC}"
    while true; do
        read -p "Utilisateur Zoraxy : " u
        read -s -p "Mot de passe : " p
        echo ""
        curl -s -k -X POST -c "$COOKIE_FILE" -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" -d "username=$u" -d "password=$p" "$ZORAXY_API_URL/api/auth/login" > /dev/null
        if check_zoraxy_auth; then echo -e "${GREEN}Connect√©.${NC}"; return 0; else echo -e "${RED}Identifiants incorrects.${NC}"; fi
    done
}

api_req() {
    endpoint="$1"
    shift
    HOMEPAGE=$(curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/")
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" "$@" "$ZORAXY_API_URL$endpoint"
}

get_zoraxy_acls() {
    if ! ensure_zoraxy_auth; then return 1; fi
    curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/api/access/list" | jq -r '.[] | "\(.ID)|\(.Name)"' 2>/dev/null
}

add_zoraxy_host() {
    local domain="$1"; local target="$2"; local acl="$3"
    if ! ensure_zoraxy_auth; then return 1; fi
    echo " > Zoraxy: Ajout Proxy $domain -> $target"
    RESPONSE=$(api_req "/api/proxy/add" --data-urlencode "type=host" --data-urlencode "rootname=$domain" --data-urlencode "ep=$target" --data-urlencode "tls=false")
    if echo "$RESPONSE" | grep -q "error"; then echo -e "${RED}‚ùå Erreur Zoraxy:${NC} $RESPONSE"; check_zoraxy_health; return 1; fi
    if [ -n "$acl" ]; then
        api_req "/api/access/attach" --data-urlencode "id=$acl" --data-urlencode "host=$domain" > /dev/null
    fi
    echo -e "${GREEN}‚úÖ Zoraxy configur√©.${NC}"; check_zoraxy_health; return 0
}

request_zoraxy_ssl() {
    local domain="$1"
    if ! ensure_zoraxy_auth; then return 1; fi
    echo -e " > Zoraxy: üîë Demande SSL (Let's Encrypt)..."
    read -p "Email (Entr√©e pour admin@$domain) : " ssl_email
    [ -z "$ssl_email" ] && ssl_email="admin@$domain"
    
    RESPONSE=$(api_req "/api/acme/obtainCert" --data-urlencode "domains=$domain" --data-urlencode "filename=$domain" --data-urlencode "email=$ssl_email" --data-urlencode "ca=Let's Encrypt" --data-urlencode "skipTLS=false" --data-urlencode "dns=false")
    
    if echo "$RESPONSE" | grep -q "error"; then echo -e "${RED}‚ùå Erreur Zoraxy:${NC}"; echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"; else echo -e "${GREEN}‚úÖ Demande envoy√©e.${NC}"; fi
    check_zoraxy_health
}

delete_zoraxy_host() {
    local domain="$1"
    if ! ensure_zoraxy_auth; then return 1; fi
    echo " > Zoraxy: Suppression Proxy $domain"
    api_req "/api/proxy/del" --data-urlencode "type=host" --data-urlencode "ep=$domain" > /dev/null
    echo -e "${GREEN}‚úÖ Zoraxy nettoy√©.${NC}"; check_zoraxy_health
}

delete_zoraxy_cert() {
    local cert="$1"
    if ! ensure_zoraxy_auth; then return 1; fi
    echo " > Zoraxy: Suppression Certificat $cert"
    api_req "/api/cert/delete" --data-urlencode "file=$cert" > /dev/null
    echo -e "${GREEN}‚úÖ Certificat supprim√©.${NC}"
}

# =======================================================
#  3. MODULE API INFOMANIAK
# =======================================================

create_infomaniak_record() {
    local source_sub="$1"; local target="$2"; local record_type="CNAME"
    if [[ "$target" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then record_type="A"; echo " > Infomaniak: D√©tection IP -> Mode 'A'"; else echo " > Infomaniak: D√©tection Domaine -> Mode 'CNAME'"; fi
    echo " > Infomaniak: Cr√©ation $record_type $source_sub -> $target..."
    JSON_DATA=$(jq -n --arg type "$record_type" --arg source "$source_sub" --arg target "$target" --arg ttl "3600" '{type: $type, source: $source, target: $target, ttl: $ttl|tonumber}')
    RESPONSE=$(curl -s -X POST "https://api.infomaniak.com/1/domain/$REGISTAR_DOMAIN_ID/dns/record" -H "Authorization: Bearer $REGISTAR_TOKEN" -H "Content-Type: application/json" -d "$JSON_DATA")
    STATUS=$(echo "$RESPONSE" | jq -r '.result')
    if [ "$STATUS" == "success" ]; then echo -e "${GREEN}‚úÖ DNS cr√©√©.${NC}"; return 0; else echo -e "${RED}‚ùå Erreur Infomaniak:${NC}"; echo "$RESPONSE" | jq -r '.error.description // .'; return 1; fi
}

delete_infomaniak_record() {
    local source_sub="$1"; echo " > Infomaniak: Recherche ID pour $source_sub..."
    RECORD_ID=$(curl -s -X GET "https://api.infomaniak.com/1/domain/$REGISTAR_DOMAIN_ID/dns/record" -H "Authorization: Bearer $REGISTAR_TOKEN" | jq -r --arg src "$source_sub" '.data[] | select(.source==$src) | .id' | head -n 1)
    if [ -n "$RECORD_ID" ] && [ "$RECORD_ID" != "null" ]; then
        echo " > Infomaniak: Suppression ID $RECORD_ID..."
        curl -s -X DELETE "https://api.infomaniak.com/1/domain/$REGISTAR_DOMAIN_ID/dns/record/$RECORD_ID" -H "Authorization: Bearer $REGISTAR_TOKEN" > /dev/null
        echo -e "${GREEN}‚úÖ DNS supprim√©.${NC}"
    else echo -e "${YELLOW}‚ö†Ô∏è  Aucun enregistrement DNS trouv√©.${NC}"; fi
}

# =======================================================
#  4. GESTION DEPLOIEMENT & CONTENU
# =======================================================

handle_github_setup() {
    local target_dir="$1"; local github_url="$2"; local web_root_suffix=""
    echo -e "\n${BLUE}--- D√âPLOIEMENT GITHUB ---${NC}"
    if [ -d "$target_dir" ] && [ "$(ls -A "$target_dir")" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Dossier non vide. Nettoyage...${NC}"
        run_sudo rm -rf "$target_dir"/* "$target_dir"/.* 2>/dev/null
    fi
    echo "Clonage de $github_url..."
    if ! run_sudo git clone "$github_url" "$target_dir"; then echo -e "${RED}‚ùå √âchec Git.${NC}"; return 1; fi
    run_sudo chown -R $USER:www-data "$target_dir"
    
    if [ -f "$target_dir/composer.json" ]; then
        echo -e "\n${CYAN}üêò composer.json d√©tect√©.${NC}"
        if command -v composer &> /dev/null; then cd "$target_dir" && composer install --no-dev --optimize-autoloader
        else echo -e "${RED}‚ö†Ô∏è  Composer manquant.${NC}"; fi
    fi
    if [ -f "$target_dir/package.json" ]; then
        echo -e "\n${CYAN}üì¶ package.json d√©tect√©.${NC}"
        if command -v npm &> /dev/null; then cd "$target_dir" && npm install && npm run build 2>/dev/null || echo "Pas de script build."
        else echo -e "${RED}‚ö†Ô∏è  NPM manquant.${NC}"; fi
    fi

    echo -e "\n${YELLOW}üìÇ Racine Web (Web Root)${NC}"
    declare -a candidates; candidates+=("/")
    for d in public web dist html build; do [ -d "$target_dir/$d" ] && candidates+=("/$d"); done
    for i in "${!candidates[@]}"; do echo "  [$i] .${candidates[$i]}"; done
    read -p "Choix (0) : " root_sel
    if [[ "$root_sel" =~ ^[0-9]+$ ]] && [ "$root_sel" -le "${#candidates[@]}" ]; then
        web_root_suffix="${candidates[$root_sel]}"; [ "$web_root_suffix" == "/" ] && web_root_suffix=""
    else web_root_suffix=""; fi
    echo -e "${GREEN}‚úÖ Racine : $target_dir$web_root_suffix${NC}"
    run_sudo chown -R www-data:www-data "$target_dir"
    echo "$web_root_suffix" > /tmp/nginx_webroot_suffix
    return 0
}

perform_rollback() {
    echo -e "\n${RED}${BOLD}üö® ERREUR D√âTECT√âE - D√âBUT DU ROLLBACK AUTOMATIQUE${NC}"
    [ "$RB_ZORAXY" -eq 1 ] && { echo " üîô Zoraxy..."; delete_zoraxy_host "$VAL_FQDN"; }
    [ "$RB_DNS" -eq 1 ] && { echo " üîô DNS..."; delete_infomaniak_record "$VAL_SUB"; }
    [ "$RB_UFW" -eq 1 ] && { echo " üîô Firewall..."; run_sudo ufw delete allow "$RB_PORT/tcp" >/dev/null; }
    [ "$RB_NGINX" -eq 1 ] && { echo " üîô Nginx..."; run_sudo rm "$SITES_AVAIL/$VAL_FQDN.conf" 2>/dev/null; run_sudo rm "$SITES_ENAB/$VAL_FQDN.conf" 2>/dev/null; run_sudo systemctl reload nginx; }
    [ "$RB_FOLDER" -eq 1 ] && { echo " üîô Dossier..."; run_sudo rm -rf "$DIR_WEB/$VAL_FQDN"; }
    echo -e "${RED}‚ùå Op√©ration annul√©e et nettoyage effectu√©.${NC}"; pause
}

# --- NOYAU DE DEPLOIEMENT S√âCURIS√â ---
core_deployment_wizard() {
    local mode="$1" 
    RB_FOLDER=0; RB_NGINX=0; RB_UFW=0; RB_DNS=0; RB_ZORAXY=0; RB_PORT=""

    # 1. NOM DE DOMAINE & VALIDATION
    echo -e "\n${BLUE}=== √âTAPE 1 : DOMAINE & SOURCE ===${NC}"
    while true; do
        read -p "Sous-domaine (ex: 'app') : " raw_input
        if [[ "$raw_input" =~ ^[a-zA-Z0-9._-]+$ ]]; then
            break
        else
            echo -e "${RED}Caract√®res invalides. R√©essayez.${NC}"
        fi
    done
    normalize_domain_input "$raw_input"
    echo -e "   -> Domaine complet : ${CYAN}$VAL_FQDN${NC}"
    
    # 2. SOURCE DU CONTENU
    echo -e "\n${YELLOW}Quelle est la source du projet ?${NC}"
    echo "1. Site Vierge (Page par d√©faut)"
    echo "2. Import GitHub (Clone + Build)"
    read -p "> " src_choice
    source_type="vierge"; github_url=""
    if [ "$src_choice" == "2" ]; then
        source_type="github"
        while [ -z "$github_url" ]; do
            read -p "URL du d√©p√¥t GitHub : " github_url
        done
    fi

    # 3. PORT & VALIDATION DISPONIBILIT√â
    echo -e "\n${BLUE}=== √âTAPE 2 : CONFIGURATION R√âSEAU ===${NC}"
    while true; do
        read -p "Port Nginx Local (ex: 8081) : " port
        if [[ "$port" =~ ^[0-9]+$ ]] && [ "$port" -ge 1024 ] && [ "$port" -le 65535 ]; then
            if check_port_free "$port"; then
                echo -e "${GREEN}‚úÖ Port $port disponible.${NC}"
                RB_PORT="$port"
                break
            else
                echo -e "${RED}‚ùå Port $port d√©j√† utilis√©. Choisissez-en un autre.${NC}"
            fi
        else
            echo -e "${RED}Port invalide (1024-65535).${NC}"
        fi
    done
    
    # 4. CIBLE DNS
    local default_target="$REGISTAR_DOMAIN_ID"
    [ "$mode" == "lan" ] && default_target="$LOCAL_IP"
    echo -e "\nCible DNS (Entr√©e = ${GREEN}$default_target${NC}) :"
    read -p " > " dns_target
    [ -z "$dns_target" ] && dns_target="$default_target"
    if [[ ! "$dns_target" =~ ^[0-9]+ ]]; then [[ "$dns_target" != *.* ]] && dns_target="${dns_target}.${REGISTAR_DOMAIN_ID}"; fi
    [[ "$dns_target" == "$VAL_FQDN" ]] && dns_target="$default_target"

    # 5. ACL ZORAXY
    SELECTED_ACL_ID=""; SELECTED_ACL_NAME="Aucune (Public)"
    if [ "$mode" == "lan" ]; then
        echo -e "\n${YELLOW}üîç Configuration ACL (R√©seau Local)${NC}"
        RAW_ACLS=$(get_zoraxy_acls)
        AUTO_ACL_ID=$(echo "$RAW_ACLS" | grep -iE "LAN|Local|Private" | head -n 1 | cut -d'|' -f1)
        AUTO_ACL_NAME=$(echo "$RAW_ACLS" | grep -iE "LAN|Local|Private" | head -n 1 | cut -d'|' -f2)
        if [ -n "$AUTO_ACL_ID" ]; then SELECTED_ACL_ID="$AUTO_ACL_ID"; SELECTED_ACL_NAME="$AUTO_ACL_NAME"; echo -e "‚úÖ ACL Automatique : ${GREEN}$SELECTED_ACL_NAME${NC}"; else
            echo -e "${YELLOW}‚ö†Ô∏è  Choisissez l'ACL :${NC}"
            declare -a ACL_IDS; declare -a ACL_NAMES; local i=1
            while IFS='|' read -r id name; do
                display_name="${name:-$id}"; echo "  $i. $display_name"; ACL_IDS+=("$id"); ACL_NAMES+=("$display_name"); ((i++))
            done <<< "$RAW_ACLS"
            read -p "Num√©ro ACL : " acl_idx
            if [[ "$acl_idx" =~ ^[0-9]+$ ]]; then SELECTED_ACL_ID="${ACL_IDS[$((acl_idx-1))]}"; SELECTED_ACL_NAME="${ACL_NAMES[$((acl_idx-1))]}"; fi
        fi
    fi

    # 6. SSL
    echo -e "\n${BLUE}=== √âTAPE 3 : S√âCURIT√â ===${NC}"
    echo "G√©n√©rer un certificat SSL (Let's Encrypt) ?"
    read -p " (o/n) > " ssl_choice

    # R√âSUM√â FINAL
    echo -e "\n${YELLOW}‚ïî‚ïê‚ïê‚ïê‚ïê R√âSUM√â DU D√âPLOIEMENT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${YELLOW}‚ïë${NC} Site       : ${CYAN}$VAL_FQDN${NC}"
    echo -e "${YELLOW}‚ïë${NC} Source     : $source_type"
    echo -e "${YELLOW}‚ïë${NC} Port       : $port"
    echo -e "${YELLOW}‚ïë${NC} Acc√®s      : $mode ($SELECTED_ACL_NAME)"
    echo -e "${YELLOW}‚ïë${NC} SSL        : $ssl_choice"
    echo -e "${YELLOW}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    
    read -p "Confirmer le d√©ploiement ? (o/n) : " c; if [ "$c" != "o" ]; then return; fi

    # --- EXECUTION ---
    
    echo -e "\n${BOLD}[1/6] Installation du contenu...${NC}"
    if ! ask_sudo_gui; then return; fi
    
    docroot="$DIR_WEB/$VAL_FQDN"
    if [ ! -d "$docroot" ]; then run_sudo mkdir -p "$docroot"; RB_FOLDER=1; fi
    
    WEB_ROOT_SUFFIX=""
    if [ "$source_type" == "github" ]; then
        handle_github_setup "$docroot" "$github_url"
        if [ $? -ne 0 ]; then perform_rollback; return; fi
        WEB_ROOT_SUFFIX=$(cat /tmp/nginx_webroot_suffix 2>/dev/null); rm /tmp/nginx_webroot_suffix 2>/dev/null
    else
        echo "<h1>Site $VAL_FQDN</h1><p>Mode: $mode</p>" | run_sudo tee "$docroot/index.html" >/dev/null
        run_sudo chown -R www-data:www-data "$docroot"
    fi

    echo -e "\n${BOLD}[2/6] Configuration Nginx...${NC}"
    conf="$SITES_AVAIL/$VAL_FQDN.conf"
    if [ -f "$conf" ]; then echo -e "${YELLOW}‚ö†Ô∏è  Fichier conf existant √©cras√©.${NC}"; fi
    
    cat <<EOF | run_sudo tee "$conf" > /dev/null
server {
    listen $port;
    server_name $VAL_FQDN _;
    root $docroot$WEB_ROOT_SUFFIX;
    index index.html index.php;
    absolute_redirect off;
    access_log /var/log/nginx/${VAL_SUB}_access.log;
    error_log /var/log/nginx/${VAL_SUB}_error.log;
    location / { try_files \$uri \$uri/ =404; }
}
EOF
    RB_NGINX=1
    run_sudo ln -sf "$conf" "$SITES_ENAB/$VAL_FQDN.conf"
    if ! run_sudo systemctl reload nginx; then echo "Erreur Reload Nginx"; perform_rollback; return; fi

    echo -e "${BOLD}[3/6] Firewall...${NC}"; run_sudo ufw allow "$port/tcp" >/dev/null; RB_UFW=1
    echo -e "${BOLD}[4/6] DNS...${NC}"; create_infomaniak_record "$VAL_SUB" "$dns_target"; if [ $? -ne 0 ]; then perform_rollback; return; fi; RB_DNS=1
    echo -e "${BOLD}[5/6] Zoraxy...${NC}"; add_zoraxy_host "$VAL_FQDN" "$LOCAL_IP:$port" "$SELECTED_ACL_ID"; if [ $? -ne 0 ]; then perform_rollback; return; fi; RB_ZORAXY=1
    
    if [[ "$ssl_choice" == "o" || "$ssl_choice" == "O" || "$ssl_choice" == "y" ]]; then
        echo -e "${BOLD}[6/6] SSL...${NC}"; request_zoraxy_ssl "$VAL_FQDN"
    else echo -e "${BOLD}[6/6] SSL ignor√©.${NC}"; fi

    echo -e "\n${GREEN}üéâ Termin√© ! Site en ligne.${NC}"
    read -p "√âditer Nginx maintenant ? (o/n) " ed
    if [ "$ed" == "o" ]; then run_sudo nano "$conf"; run_sudo systemctl reload nginx; fi
    pause
}

wizard_new_site_menu() {
    clear
    echo -e "${BLUE}################################################${NC}"
    echo -e "${BLUE}#           CR√âATION D'UN NOUVEAU SITE         #${NC}"
    echo -e "${BLUE}################################################${NC}"
    echo "Quel type d'acc√®s souhaitez-vous ?"
    echo ""
    echo -e "${GREEN}1. üåç SITE PUBLIC (INTERNET)${NC}"
    echo -e "   ${GREY}Exemple : blog.grandepharmaciebonaparte.fr${NC}"
    echo -e "   ${GREY}‚ÑπÔ∏è  Accessible depuis 4G/Ext√©rieur. S√©curis√© par Zoraxy.${NC}"
    echo ""
    echo -e "${YELLOW}2. üè† SITE PRIV√â (R√âSEAU LOCAL)${NC}"
    echo -e "   ${GREY}Exemple : nas.grandepharmaciebonaparte.fr${NC}"
    echo -e "   ${GREY}‚ÑπÔ∏è  Accessible UNIQUEMENT depuis le r√©seau de la pharmacie.${NC}"
    echo ""
    echo -e "${RED}0. Retour${NC}"
    
    read -p "Votre choix > " access_type
    
    case "$access_type" in
        1) core_deployment_wizard "public" ;;
        2) 
            echo -e "\n${YELLOW}--- Options Site Priv√© ---${NC}"
            echo "1. Avec Nom de Domaine (Recommand√©)"
            echo "2. Par IP Directe (Simple)"
            read -p "> " sub
            [ "$sub" == "1" ] && core_deployment_wizard "lan"
            [ "$sub" == "2" ] && create_simple_vhost_wizard
            ;;
    esac
}

create_simple_vhost_wizard() {
    echo -e "\n${GREEN}‚ûï SITE SIMPLE (IP:PORT)${NC}"
    echo "Ce site sera accessible via http://$LOCAL_IP:PORT"
    read -p "Nom du projet : " d; [ -z "$d" ] && return
    
    # Check port
    while true; do
        read -p "Port : " port
        if check_port_free "$port"; then break; else echo "${RED}Port occup√©.${NC}"; fi
    done

    if ! ask_sudo_gui; then return; fi
    setup_site_content "$DIR_WEB/$d" "Local"
    conf="$SITES_AVAIL/$d.conf"
    cat <<EOF | run_sudo tee "$conf" > /dev/null
server {
    listen $port;
    server_name _;
    root $DIR_WEB/$d;
    index index.html;
    absolute_redirect off;
}
EOF
    run_sudo ln -sf "$conf" "$SITES_ENAB/$d.conf"
    run_sudo ufw allow "$port/tcp" >/dev/null
    run_sudo systemctl reload nginx
    echo -e "\n${GREEN}‚úÖ Site actif.${NC}"; pause
}

# --- ACTIONS SUPPLEMENTAIRES ---

action_toggle_vhost() {
    refresh_dashboard_table; read -p "Site # (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"; bn=$(basename "$f")
    if ask_sudo_gui; then
        if ls "$SITES_ENAB/$bn"* 1>/dev/null 2>&1; then run_sudo rm "$SITES_ENAB/$bn"*; echo -e "${RED}üî¥ D√©sactiv√©.${NC}"; else run_sudo ln -sf "$f" "$SITES_ENAB/$bn"; echo -e "${GREEN}üü¢ Activ√©.${NC}"; fi
        run_sudo systemctl reload nginx; pause
    fi
}

action_edit_vhost() {
    refresh_dashboard_table; read -p "Site # (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"
    if ask_sudo_gui; then
        run_sudo cp "$f" "$f.bak_tmp"; run_sudo nano "$f"
        if run_sudo nginx -t; then run_sudo rm "$f.bak_tmp"; run_sudo systemctl reload nginx; else echo "${RED}Erreur Syntaxe!${NC}"; run_sudo mv "$f.bak_tmp" "$f"; fi
        pause
    fi
}

action_ssl_retry() {
    refresh_dashboard_table; read -p "Site # (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"; filename=$(basename "$f"); domain_conf="${filename%.*}"
    request_zoraxy_ssl "$domain_conf"; pause
}

action_cleanup_ssl() {
    echo -e "\n${BLUE}### NETTOYAGE CERTIFICATS ###${NC}"
    if ! ensure_zoraxy_auth; then return; fi
    echo "Analyse en cours..."
    
    # LISTING
    ACTIVE_HOSTS=$(api_req "/api/proxy/list" --data-urlencode "type=host" | jq -r 'to_entries[] | "\(.value.RootOrMatchingDomain)"')
    CERTS=$(api_req "/api/cert/list" | jq -r '.[]')
    
    declare -a CERT_FILES; declare -a CERT_STATUS_TXT; declare -a CERT_LINKS_TXT; declare -a CERT_COLOR; declare -a SELECTED; idx=0
    
    # 1. Calcul largeur Max
    MAX_LEN=20
    for cert in $CERTS; do
        len=${#cert}; if (( len > MAX_LEN )); then MAX_LEN=$len; fi
    done
    MAX_LEN=$((MAX_LEN + 2)) 

    # 2. Remplissage
    for cert in $CERTS; do
        cert_name="${cert%.pem}"; cert_name="${cert_name%.crt}"
        [[ "$cert_name" == "server" || "$cert_name" == "ca" ]] && continue
        
        CERT_FILES[$idx]="$cert"; is_used=0; linked_host="-"
        
        if echo "$ACTIVE_HOSTS" | grep -qx "$cert_name"; then is_used=1; linked_host="$cert_name";
        else
            if [[ "$cert_name" == *"_"* || "$cert_name" == *"wildcard"* ]]; then is_used=1; linked_host="Wildcard (Secu)"; fi
        fi
        
        if [ $is_used -eq 1 ]; then 
            CERT_STATUS_TXT[$idx]="UTILIS√â"; CERT_COLOR[$idx]=$GREEN; CERT_LINKS_TXT[$idx]="$linked_host"; SELECTED[$idx]=0
        else 
            CERT_STATUS_TXT[$idx]="ORPHELIN"; CERT_COLOR[$idx]=$RED; CERT_LINKS_TXT[$idx]="Aucun"; SELECTED[$idx]=1
        fi
        ((idx++))
    done
    if [ $idx -eq 0 ]; then echo "Aucun certificat."; pause; return; fi

    # 3. Affichage ALIGN√â (Couleurs hors du formatage de largeur)
    while true; do
        clear; echo -e "${BLUE}=== GESTION SSL ===${NC}"
        # Header Dynamique avec la largeur calcul√©e
        printf "%-4s %-5s %-${MAX_LEN}s %-15s %-30s\n" "N¬∞" "DEL" "CERTIFICAT" "√âTAT" "SITE LI√â"
        echo "--------------------------------------------------------------------------------"
        for ((i=0; i<idx; i++)); do
            if [ "${SELECTED[$i]}" -eq 1 ]; then
                t_mark="[X]"
                c_mark="$RED"
            else
                t_mark="[ ]"
                c_mark="" # Pas de couleur = blanc/d√©faut
            fi
            
            # Utilisation de %b pour les couleurs autour des cha√Ænes pour ne pas casser l'alignement
            printf "%-4s %b%-5s%b %-${MAX_LEN}s %b%-15s%b %b%-30s%b\n" \
                "$((i+1))" \
                "$c_mark" "$t_mark" "$NC" \
                "${CERT_FILES[$i]}" \
                "${CERT_COLOR[$i]}" "${CERT_STATUS_TXT[$i]}" "$NC" \
                "$GREY" "${CERT_LINKS_TXT[$i]}" "$NC"
        done
        echo -e "\n [N¬∞] Cocher/D√©cocher | [v] Valider | [0] Annuler"
        read -p "> " input
        if [ "$input" == "0" ]; then return; fi
        if [ "$input" == "v" ]; then break; fi
        if [[ "$input" =~ ^[0-9]+$ ]] && [ "$input" -ge 1 ] && [ "$input" -le "$idx" ]; then
            r=$((input-1)); if [ "${SELECTED[$r]}" -eq 1 ]; then SELECTED[$r]=0; else SELECTED[$r]=1; fi
        fi
    done
    
    count=0
    for ((i=0; i<idx; i++)); do
        if [ "${SELECTED[$i]}" -eq 1 ]; then
            echo -n "Suppression ${CERT_FILES[$i]}... "
            api_req "/api/cert/delete" --data-urlencode "file=${CERT_FILES[$i]}" > /dev/null
            echo "OK"
            ((count++))
        fi
    done
    echo -e "${GREEN}$count certificats supprim√©s.${NC}"
    check_zoraxy_health; pause
}

action_delete_wizard() {
    refresh_dashboard_table; read -p "Site # √† SUPPRIMER (0=Retour) : " sel; [ "$sel" == "0" ] && return
    
    f="${VHOST_FILES[$((sel-1))]}"; filename=$(basename "$f")
    content=$(sudo cat "$f" 2>/dev/null)
    domain_conf=$(echo "$content" | grep "server_name" | awk '{print $2}' | sed 's/;//')
    if [ "$domain_conf" == "_" ]; then domain_conf="${filename%.*}"; fi
    target_port=$(echo "$content" | grep -E "^\s*listen" | grep -oE "[0-9]+" | head -n1)
    normalize_domain_input "$domain_conf"
    
    echo -e "\n${RED}${BOLD}üóëÔ∏è  SUPPRESSION DE : $domain_conf${NC}"
    echo "Analyse des ressources associ√©es..."
    
    # 1. Check Dossier Web
    d_web="NON"
    if [ -d "$DIR_WEB/$domain_conf" ]; then d_web="${RED}OUI ($DIR_WEB/$domain_conf)${NC}"; has_web=1; else d_web="${GREEN}NON${NC}"; has_web=0; fi
    
    # 2. Check Proxy Zoraxy
    d_proxy="NON"
    has_proxy=0
    if check_zoraxy_health; then
        if api_req "/api/proxy/list" --data-urlencode "type=host" | grep -q "$VAL_FQDN"; then
            d_proxy="${RED}OUI (Proxy Actif)${NC}"; has_proxy=1
        else
            d_proxy="${GREEN}NON${NC}"
        fi
    fi
    
    # 3. Check Certificat SSL
    d_cert="NON"
    has_cert=0
    if check_zoraxy_health; then
        if api_req "/api/cert/list" | grep -q "$VAL_FQDN"; then
            d_cert="${RED}OUI (Certificat trouv√©)${NC}"; has_cert=1
        else
            d_cert="${GREEN}NON${NC}"
        fi
    fi
    
    # RESUME DU SCAN
    echo -e "\n${YELLOW}Ressources trouv√©es :${NC}"
    echo -e " - Config Nginx : ${RED}OUI ($filename)${NC}"
    echo -e " - Dossier Web  : $d_web"
    echo -e " - Proxy Zoraxy : $d_proxy"
    echo -e " - Certificat   : $d_cert"
    echo -e " - Entr√©e DNS   : ${RED}OUI (Infomaniak)${NC}"
    
    # QUESTIONS INTELLIGENTES
    echo -e "\n${BOLD}Que voulez-vous faire ?${NC}"
    
    del_web="n"; del_proxy="n"; del_cert="n"; del_dns="n"
    
    if [ $has_web -eq 1 ]; then read -p " > Supprimer le dossier web ? (o/n) " del_web; fi
    if [ $has_proxy -eq 1 ]; then read -p " > Supprimer le Proxy Zoraxy ? (o/n) " del_proxy; fi
    if [ $has_cert -eq 1 ]; then read -p " > Supprimer le Certificat SSL ? (o/n) " del_cert; fi
    read -p " > Supprimer l'entr√©e DNS Infomaniak ? (o/n) " del_dns
    
    echo -e "\n${RED}CONFIRMATION FINALE${NC}"
    read -p "Tapez 'oui' pour ex√©cuter la suppression : " confirm
    if [ "$confirm" != "oui" ]; then echo "Annul√©."; pause; return; fi
    
    if ! ask_sudo_gui; then return; fi

    # EXECUTION
    echo ""
    if [ "$del_dns" == "o" ]; then delete_infomaniak_record "$VAL_SUB"; fi
    if [ "$del_proxy" == "o" ]; then delete_zoraxy_host "$VAL_FQDN"; fi
    if [ "$del_cert" == "o" ]; then delete_zoraxy_cert "$VAL_FQDN.pem"; fi # Zoraxy stocke souvent en .pem
    
    [ -n "$target_port" ] && run_sudo ufw delete allow "$target_port/tcp" >/dev/null
    
    echo "Suppression Nginx..."
    target_link=$(find "$SITES_ENAB" -name "$filename*"); [ -n "$target_link" ] && run_sudo rm "$target_link"
    run_sudo rm "$f"; run_sudo systemctl reload nginx
    
    if [ "$del_web" == "o" ]; then 
        echo "Suppression Dossier..."
        run_sudo rm -rf "$DIR_WEB/$domain_conf"
    fi
    
    echo -e "${GREEN}Termin√©.${NC}"; pause
}

# =======================================================
#  6. DASHBOARD & GESTION SITES (TABLEAU UNIFI√â & ALIGN√â)
# =======================================================

declare -a VHOST_FILES

refresh_dashboard_table() {
    VHOST_FILES=()
    shopt -s nullglob
    local files=("$SITES_AVAIL"/*)
    shopt -u nullglob
    
    # R√©cup√©ration Zoraxy Proxies
    if check_zoraxy_health; then
        Z_PROXIES=$(api_req "/api/proxy/list" --data-urlencode "type=host" | jq -r 'to_entries[] | select(.value | type == "object") | "\(.value.ActiveOrigins[0].OriginIpOrDomain // "null")|\(.value.RootOrMatchingDomain)|\(.value.UseTLS)"')
    else
        Z_PROXIES=""
    fi
    
    Z_CERTS=$(api_req "/api/cert/list" | jq -r '.[]')

    echo -e "${BLUE}=== TABLEAU DE BORD DES SITES WEB ===${NC}"
    printf "%-3s %-45s %-8s %-40s %-20s\n" "ID" "DOMAINE PUBLIC (ZORAXY)" "PORT" "RACINE WEB" "SSL (ZORAXY)"
    echo "-----------------------------------------------------------------------------------------------------------------------"
    
    if [ ${#files[@]} -eq 0 ]; then echo "   (Aucun site configur√©)"; else
        local i=1
        for f in "${files[@]}"; do
            VHOST_FILES+=("$f")
            
            content=$(sudo cat "$f" 2>/dev/null)
            port=$(echo "$content" | grep -E "^\s*listen" | grep -oE "[0-9]+" | head -n1)
            [ -z "$port" ] && port="-"
            root_dir=$(echo "$content" | grep -E "^\s*root" | awk '{print $2}' | sed 's/;//')
            
            # Contenu brut (sans couleurs pour l'alignement)
            zoraxy_host_txt="Non li√©"
            ssl_status_txt="-"
            
            # Couleurs (√† appliquer s√©par√©ment)
            c_host=$GREY
            c_ssl=$GREY
            
            if [ -n "$port" ] && [ "$port" != "-" ]; then
                z_match=$(echo "$Z_PROXIES" | grep ":$port|")
                if [ -n "$z_match" ]; then
                    IFS='|' read -r z_origin z_domain z_tls <<< "$z_match"
                    zoraxy_host_txt="$z_domain"
                    c_host=$CYAN
                    
                    if [ "$z_tls" == "true" ]; then 
                        if echo "$Z_CERTS" | grep -q "$z_domain"; then
                            cert_file="$ZORAXY_ACME_DIR/${z_domain}.pem"
                            if sudo [ -f "$cert_file" ]; then
                                end_date=$(sudo openssl x509 -enddate -noout -in "$cert_file" | cut -d= -f2)
                                parsed_date=$(date -d "$end_date" +%d/%m/%y 2>/dev/null)
                                ssl_status_txt="Oui ($parsed_date)"
                                c_ssl=$GREEN
                            else
                                ssl_status_txt="Activ√©"
                                c_ssl=$GREEN
                            fi
                        else
                            ssl_status_txt="Activ√© (No Cert)"
                            c_ssl=$YELLOW
                        fi
                    else 
                        ssl_status_txt="D√©sactiv√©"
                        c_ssl=$RED
                    fi
                fi
            fi

            # Troncature pour l'alignement
            d_dom="${zoraxy_host_txt:0:44}"
            d_root="${root_dir:0:39}"

            printf "%-3s %b%-45s%b %-8s %-40s %b%-20s%b\n" \
                "$i" \
                "$c_host" "$d_dom" "$NC" \
                "$port" \
                "$d_root" \
                "$c_ssl" "$ssl_status_txt" "$NC"
            ((i++))
        done
    fi
    echo "-----------------------------------------------------------------------------------------------------------------------"
}

manage_nginx_sites_menu() {
    while true; do
        clear
        refresh_dashboard_table
        echo ""
        echo -e " ${BOLD}${CYAN}üöÄ D√âPLOIEMENT${NC}"
        echo -e "   ${GREEN}1.${NC} ‚ú® Cr√©er un nouveau Site      ${GREY}(Vierge ou GitHub)${NC}"
        echo ""
        echo -e " ${BOLD}${CYAN}üîß MAINTENANCE & CONFIG${NC}"
        echo -e "   ${YELLOW}2.${NC} ‚èØÔ∏è  Activer / D√©sactiver      ${GREY}(ON/OFF sans suppression)${NC}"
        echo -e "   ${CYAN}3.${NC} üìù √âditer Configuration      ${GREY}(Vhost Nginx + Nano)${NC}"
        echo -e "   ${BLUE}4.${NC} üîë R√©parer / Forcer SSL      ${GREY}(Renouvellement Zoraxy)${NC}"
        echo -e "   ${BLUE}8.${NC} üßπ Nettoyer Certificats      ${GREY}(S√©lecteur interactif)${NC}"
        echo ""
        echo -e " ${BOLD}${CYAN}üóëÔ∏è  ZONE DE DANGER${NC}"
        echo -e "   ${RED}5.${NC} üí• Supprimer un Site         ${GREY}(Assistant Intelligent)${NC}"
        echo ""
        echo -e "  ${RED}0.${NC} üîô Retour au Menu Principal"
        
        read -r -p "  Votre choix > " ch
        case "$ch" in
            1) wizard_new_site_menu ;;
            2) action_toggle_vhost ;;
            3) action_edit_vhost ;;
            4) action_ssl_retry ;;
            5) action_delete_wizard ;;
            8) action_cleanup_ssl ;;
            0) break ;;
        esac
    done
}

# =======================================================
#  7. MENU SYSTEME & LOOP
# =======================================================

firewall_manager() {
    while true; do
        clear; echo -e "${BLUE}=== GESTION PARE-FEU ===${NC}"
        run_sudo ufw status numbered
        echo -e "1. Ouvrir Port | 2. Supprimer R√®gle | 0. Retour"
        read -r -p "> " c
        case "$c" in
            1) read -p "Port: " p; [ -n "$p" ] && ask_sudo_gui && run_sudo ufw allow "$p"; pause ;;
            2) read -p "Num√©ro: " n; [ -n "$n" ] && ask_sudo_gui && echo "y" | run_sudo ufw delete "$n"; pause ;;
            0) return ;;
        esac
    done
}

deploy_from_github() { echo "Obsol√®te."; pause; }
backup_menu() {
    while true; do
        clear; echo -e "${BLUE}=== BACKUP ===${NC}"
        ls -lh "$BACKUP_DIR" 2>/dev/null | grep "tar.gz"
        echo "1. Backup Full Nginx | 0. Retour"
        read -r -p "> " c
        if [ "$c" == "1" ] && ask_sudo_gui; then
            run_sudo mkdir -p "$BACKUP_DIR"
            run_sudo tar -czf "$BACKUP_DIR/NGINX_FULL_$(date +%Y%m%d).tar.gz" "$NGINX_HOME" "$DIR_WEB"
            echo "Backup cr√©√©."; pause
        elif [ "$c" == "0" ]; then return; fi
    done
}

while true; do
    clear; ensure_requirements; get_sys_info
    
    echo -e "${BLUE}################################################${NC}"
    echo -e "${BLUE}#           MANAGER SERVEUR WEB                #${NC}"
    echo -e "${BLUE}################################################${NC}"

    printf "  üñ•Ô∏è  %-21s | ‚è±Ô∏è  (System)\n" "${CYAN}$OS_NAME${NC}"
    printf "  üè† LAN: %-15s | üåç WAN: %s\n" "${YELLOW}$LOCAL_IP${NC}" "${YELLOW}$PUBLIC_IP${NC}"
    echo -e "$SEP"
    printf "  üîå Service : %-12b | üõ°Ô∏è  Pare-feu : %s\n" "$SX" "$FW"
    printf "  ‚ÑπÔ∏è  Version : %-12s | ‚öì Ports    : %s/%s\n" "${CYAN}$APP_VER${NC}" "${YELLOW}80${NC}" "${YELLOW}443${NC}"
    echo -e "$SEP"

    echo -e " ${BOLD}${CYAN}‚ö° GESTION DU SERVICE${NC}"
    echo -e "    ${GREEN}1.${NC} ‚ñ∂Ô∏è  D√©marrer le service"
    echo -e "    ${GREEN}2.${NC} ‚èπÔ∏è  Arr√™ter le service"
    echo -e "    ${GREEN}3.${NC} üîÑ Red√©marrer le service"
    echo -e "    ${GREEN}4.${NC} üìú Logs du service"
    echo ""
    echo -e " ${BOLD}${CYAN}üåê SITES & D√âPLOIEMENT${NC}"
    echo -e "    ${GREEN}5.${NC} üåê Gestion des Sites Web (Dashboard)"
    echo ""
    echo -e " ${BOLD}${CYAN}üõ°Ô∏è  S√âCURIT√â & MAINTENANCE${NC}"
    echo -e "    ${GREEN}7.${NC} üß± Pare-feu (UFW)"
    echo -e "    ${GREEN}9.${NC} üíæ Sauvegardes"
    echo -e "    ${GREEN}10.${NC}üöÄ Mises √† jour Syst√®me"
    echo -e "$SEP_RED"
    echo -e " ${BOLD}${RED}üíÄ ZONES SYST√àME${NC}"
    echo -e "    ${RED}11.${NC}üîå √âteindre le serveur"
    echo -e "    ${RED}12.${NC}‚ôªÔ∏è  Red√©marrer le serveur"
    echo -e "$SEP"
    echo -e "  [${RED}exit${NC}] üö™ Quitter"
    echo -e "$SEP"

    read -r -p "  Votre choix > " ch

    case "$ch" in
        1) ask_sudo_gui && run_sudo systemctl start nginx; pause ;;
        2) ask_sudo_gui && run_sudo systemctl stop nginx; pause ;;
        3) ask_sudo_gui && run_sudo systemctl restart nginx; pause ;;
        4) run_sudo tail -f "$LOG_ERROR" ;;
        5) manage_nginx_sites_menu ;;
        7) firewall_manager ;;
        9) backup_menu ;;
        10) ask_sudo_gui && sudo apt update && sudo apt upgrade -y; pause ;;
        11) ask_sudo_gui && sudo poweroff ;;
        12) ask_sudo_gui && sudo reboot ;;
        exit|q) exit 0 ;;
        *) echo "Choix invalide"; sleep 1 ;;
    esac
done
