#!/bin/bash
# ==============================
#  MANAGER SERVEUR WEB
# ==============================

# --- FICHIER DE SAUVEGARDE DE LA CONFIGURATION ---
CONFIG_FILE="$HOME/.nginx-manager.conf"

# --- VALEURS PAR D√âFAUT (Si pas de fichier de config) ---
INFOMANIAK_TOKEN=""
INFOMANIAK_DOMAIN=""
ZORAXY_IP="127.0.0.1"
ZORAXY_PORT="8000"

# --- CHARGEMENT DE LA CONFIGURATION EXTERNE ---
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# --- CALCUL DYNAMIQUE URL ---
ZORAXY_API_URL="http://$ZORAXY_IP:$ZORAXY_PORT"

# --- CONFIGURATION SYSTEME ---
DIR_WEB="/var/www"
NGINX_HOME="/etc/nginx"
SITES_AVAIL="$NGINX_HOME/sites-available"
SITES_ENAB="$NGINX_HOME/sites-enabled"
BACKUP_DIR="/var/backups/nginx-manager"
LOG_ACCESS="/var/log/nginx/access.log"
LOG_ERROR="/var/log/nginx/error.log"

# --- CONFIGURATION ZORAXY (FICHIERS) ---
COOKIE_FILE="/tmp/zoraxy_cookie_manager.txt"
ZORAXY_SERVICE_NAME="zoraxy"
ZORAXY_ACME_DIR="/etc/zoraxy/conf/certs/acme"

# --- CACHE & UTILITAIRES ---
PUBLIC_IP_CACHE="/tmp/nginx_public_ip"
CMD_NGINX="/usr/sbin/nginx"
CMD_UFW="/usr/sbin/ufw"

# --- S√âCURIT√â & COULEURS ---
trap '' SIGINT SIGQUIT SIGTSTP
BLUE=$'\033[0;34m'
GREEN=$'\033[0;32m'
RED=$'\033[0;31m'
YELLOW=$'\033[1;33m'
CYAN=$'\033[0;36m'
GREY=$'\033[1;30m'
NC=$'\033[0m'
BOLD=$'\033[1m'
SEP="------------------------------------------------"
SEP_RED="${RED}------------------------------------------------${NC}"

# =======================================================
#  0. GESTION DE LA CONFIGURATION (NOUVEAU)
# =======================================================

save_config() {
    # Sauvegarde des variables dans le fichier utilisateur
    cat <<EOF > "$CONFIG_FILE"
# Configuration Nginx Manager - Infomaniak & Zoraxy
INFOMANIAK_TOKEN="$INFOMANIAK_TOKEN"
INFOMANIAK_DOMAIN="$INFOMANIAK_DOMAIN"
ZORAXY_IP="$ZORAXY_IP"
ZORAXY_PORT="$ZORAXY_PORT"
EOF
    chmod 600 "$CONFIG_FILE"

    # Mise √† jour imm√©diate de l'URL en m√©moire
    ZORAXY_API_URL="http://$ZORAXY_IP:$ZORAXY_PORT"

    echo -e "${GREEN}‚úÖ Configuration sauvegard√©e dans $CONFIG_FILE${NC}"
    sleep 1
}

settings_menu() {
    while true; do
        clear
        echo -e "${BLUE}################################################${NC}"
        echo -e "${BLUE}#           R√âGLAGES & CONFIGURATION           #${NC}"
        echo -e "${BLUE}################################################${NC}"
        echo -e "${GREY}Fichier config : $CONFIG_FILE${NC}"
        echo ""
        echo -e "${BOLD}--- INFOMANIAK ---${NC}"

        # Masquage partiel du token
        if [ -n "$INFOMANIAK_TOKEN" ]; then
             mask_token="${INFOMANIAK_TOKEN:0:5}....................${INFOMANIAK_TOKEN: -5}"
        else
             mask_token="${RED}Non configur√©${NC}"
        fi

        echo -e "1. üîë Token API       : $mask_token"
        echo -e "2. üåç Domaine Racine  : ${CYAN}${INFOMANIAK_DOMAIN:-Non configur√©}${NC}"
        echo ""
        echo -e "${BOLD}--- ZORAXY ---${NC}"
        echo -e "3. üëΩ Adresse IP      : ${CYAN}$ZORAXY_IP${NC}"
        echo -e "4. üîå Port            : ${CYAN}$ZORAXY_PORT${NC}"
        echo -e "   ‚ÑπÔ∏è  URL API Actuelle : $ZORAXY_API_URL"
        echo ""
        echo -e "0. üîô Retour au menu principal"
        echo -e "$SEP"

        read -p "Modifier l'option > " choice
        case "$choice" in
            1)
                echo -e "\n${YELLOW}Entrez votre Token API Infomaniak :${NC}"
                read -p "> " input_token
                [ -n "$input_token" ] && INFOMANIAK_TOKEN="$input_token" && save_config
                ;;
            2)
                echo -e "\n${YELLOW}Entrez votre domaine (ex: google.com) :${NC}"
                read -p "> " input_domain
                [ -n "$input_domain" ] && INFOMANIAK_DOMAIN="$input_domain" && save_config
                ;;
            3)
                echo -e "\n${YELLOW}Nouvelle IP Zoraxy (ex: 192.168.1.50) :${NC}"
                read -p "> " input_ip
                [ -n "$input_ip" ] && ZORAXY_IP="$input_ip" && save_config
                ;;
            4)
                echo -e "\n${YELLOW}Nouveau Port Zoraxy (ex: 8000) :${NC}"
                read -p "> " input_port
                [ -n "$input_port" ] && ZORAXY_PORT="$input_port" && save_config
                ;;
            0) return ;;
            *) echo "Choix invalide"; sleep 1 ;;
        esac
    done
}

# =======================================================
#  1. FONCTIONS SYST√àME DE BASE
# =======================================================

ask_sudo_gui() {
    if sudo -n true 2>/dev/null; then return 0; fi
    echo -e "\n${YELLOW}üîí Authentification requise${NC}"
    read -s -p "Mot de passe : " user_pass
    echo ""
    echo "$user_pass" | sudo -S -v 2>/dev/null
    if [ $? -eq 0 ]; then return 0;
    else echo -e "${RED}‚ùå Incorrect.${NC}"; pause; return 1; fi
}

run_sudo() {
    if sudo -n true 2>/dev/null; then sudo "$@"; return $?; fi
    if ! ask_sudo_gui; then return 1; fi
    sudo "$@"
}

run_sudo_silent() {
    sudo -n "$@" 2>/dev/null
}

pause() {
    echo ""
    read -p "Appuyez sur Entr√©e pour continuer..."
}

ensure_requirements() {
    if ! command -v jq &> /dev/null; then echo -e "${RED}Erreur: 'jq' requis.${NC}"; exit 1; fi
    if ! command -v curl &> /dev/null; then echo -e "${RED}Erreur: 'curl' requis.${NC}"; exit 1; fi
    if ! command -v git &> /dev/null; then echo -e "${RED}Erreur: 'git' requis.${NC}"; exit 1; fi
}

get_sys_info() {
    LOCAL_IP=$(hostname -I | awk '{print $1}')

    # Cache IP Publique (1h)
    if [ -f "$PUBLIC_IP_CACHE" ] && [ $(( $(date +%s) - $(stat -c %Y "$PUBLIC_IP_CACHE") )) -lt 3600 ]; then
        PUBLIC_IP=$(cat "$PUBLIC_IP_CACHE")
    else
        PUBLIC_IP=$(curl -s -4 -m 3 https://icanhazip.com 2>/dev/null)
        [[ "$PUBLIC_IP" =~ ^[0-9.]+$ ]] && echo "$PUBLIC_IP" > "$PUBLIC_IP_CACHE" || PUBLIC_IP="N/A"
    fi

    OS_NAME=$(grep -oP 'PRETTY_NAME="\K[^"]+' /etc/os-release 2>/dev/null | cut -c1-20)
    [ -z "$OS_NAME" ] && OS_NAME="Linux"
    APP_VER=$($CMD_NGINX -v 2>&1 | awk -F/ '{print $2}')

    # --- NOUVEAU : STATS RESSOURCES ---
    # RAM : Utilise free pour calculer le pourcentage
    RAM_USAGE=$(free -m | awk 'NR==2{printf "%.1f%% (%s/%sMB)", $3*100/$2, $3, $2 }')

    # CPU : Utilise top en mode batch pour l'usage actuel (User + Sys)
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1"%"}')

    # SITES : Compte les fichiers de conf activ√©s
    SITES_COUNT=$(ls -1 "$SITES_ENAB" 2>/dev/null | wc -l)

    if systemctl is-active --quiet nginx; then SX="${GREEN}‚óè ON${NC}"; else SX="${RED}‚óè OFF${NC}"; fi
    if run_sudo_silent $CMD_UFW status 2>/dev/null | grep -q "active"; then FW="${GREEN}‚óè ACTIF${NC}"; else FW="${RED}‚óè INACTIF${NC}"; fi
}

normalize_domain_input() {
    local input="$1"
    local base="$INFOMANIAK_DOMAIN"

    if [ -z "$base" ]; then
        echo -e "${RED}Domaine non configur√© dans les r√©glages !${NC}"
        VAL_FQDN="$input"
        VAL_SUB="$input"
        return
    fi

    input="${input%.}"
    if [[ "$input" == *"$base" ]]; then
        VAL_FQDN="$input"
        VAL_SUB="${input%.$base}"
    else
        VAL_SUB="$input"
        VAL_FQDN="${input}.${base}"
    fi
}

check_port_free() {
    local port="$1"
    if sudo ss -tuln | grep -q ":$port "; then return 1; fi
    return 0
}

# =======================================================
#  2. MODULE API ZORAXY (AUTO-HEALING)
# =======================================================

check_zoraxy_health() {
    if curl -s -m 1 "$ZORAXY_API_URL/api/auth/username" >/dev/null; then return 0; fi
    echo -e "\n${RED}‚ö†Ô∏è  ALERTE : Zoraxy ne r√©pond plus ! ($ZORAXY_API_URL)${NC}"
    echo -e "${YELLOW}üîÑ Red√©marrage automatique du service...${NC}"
    run_sudo systemctl restart "$ZORAXY_SERVICE_NAME"
    for i in {1..15}; do
        if curl -s -m 1 "$ZORAXY_API_URL/api/auth/username" >/dev/null; then echo -e " ${GREEN}OK !${NC}"; return 0; fi
        echo -n "."; sleep 1
    done
    echo -e "\n${RED}‚ùå √âchec critique Zoraxy.${NC}"; return 1
}

check_zoraxy_auth() {
    [ ! -f "$COOKIE_FILE" ] && return 1
    CHECK=$(curl -s -m 2 -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/api/auth/username")
    [[ "$CHECK" == *\"* ]] && [[ "$CHECK" != *"error"* ]] && return 0
    return 1
}

ensure_zoraxy_auth() {
    if ! check_zoraxy_health; then return 1; fi
    if check_zoraxy_auth; then return 0; fi
    HOMEPAGE=$(curl -s -L -k -c "$COOKIE_FILE" -b "$COOKIE_FILE" "$ZORAXY_API_URL/" --max-time 2)
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')

    echo -e "\n${CYAN}üîê Authentification Zoraxy requise${NC}"
    while true; do
        read -p "Utilisateur Zoraxy : " u
        read -s -p "Mot de passe : " p
        echo ""
        curl -s -k -X POST -c "$COOKIE_FILE" -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" -d "username=$u" -d "password=$p" "$ZORAXY_API_URL/api/auth/login" > /dev/null
        if check_zoraxy_auth; then echo -e "${GREEN}Connect√©.${NC}"; return 0; else echo -e "${RED}Identifiants incorrects.${NC}"; fi
    done
}

api_req() {
    endpoint="$1"
    shift
    HOMEPAGE=$(curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/")
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" "$@" "$ZORAXY_API_URL$endpoint"
}

get_zoraxy_acls() {
    if ! ensure_zoraxy_auth; then return 1; fi
    curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/api/access/list" | jq -r '.[] | "\(.ID)|\(.Name)"' 2>/dev/null
}

add_zoraxy_host() {
    local domain="$1"; local target="$2"; local acl="$3"
    if ! ensure_zoraxy_auth; then return 1; fi

    echo " > Zoraxy: Ajout Proxy $domain -> $target"
    RESPONSE=$(api_req "/api/proxy/add" --data-urlencode "type=host" --data-urlencode "rootname=$domain" --data-urlencode "ep=$target" --data-urlencode "tls=false")
    if echo "$RESPONSE" | grep -q "error"; then echo -e "${RED}‚ùå Erreur Zoraxy:${NC} $RESPONSE"; check_zoraxy_health; return 1; fi
    if [ -n "$acl" ]; then
        api_req "/api/access/attach" --data-urlencode "id=$acl" --data-urlencode "host=$domain" > /dev/null
    fi
    echo -e "${GREEN}‚úÖ Zoraxy configur√©.${NC}"; check_zoraxy_health; return 0
}

request_zoraxy_ssl() {
    local domain="$1"
    if ! ensure_zoraxy_auth; then return 1; fi
    echo -e " > Zoraxy: üîë Demande SSL (Let's Encrypt)..."
    read -p "Email (Entr√©e pour admin@$domain) : " ssl_email
    [ -z "$ssl_email" ] && ssl_email="admin@$domain"

    RESPONSE=$(api_req "/api/acme/obtainCert" --data-urlencode "domains=$domain" --data-urlencode "filename=$domain" --data-urlencode "email=$ssl_email" --data-urlencode "ca=Let's Encrypt" --data-urlencode "skipTLS=false" --data-urlencode "dns=false")

    if echo "$RESPONSE" | grep -q "error"; then echo -e "${RED}‚ùå Erreur Zoraxy:${NC}"; echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE";
    else echo -e "${GREEN}‚úÖ Demande envoy√©e.${NC}"; fi
    check_zoraxy_health
}

delete_zoraxy_host() {
    local domain="$1"
    if ! ensure_zoraxy_auth; then return 1; fi
    echo " > Zoraxy: Suppression Proxy $domain"
    api_req "/api/proxy/del" --data-urlencode "type=host" --data-urlencode "ep=$domain" > /dev/null
    echo -e "${GREEN}‚úÖ Zoraxy nettoy√©.${NC}"; check_zoraxy_health
}

delete_zoraxy_cert() {
    local cert="$1"
    if ! ensure_zoraxy_auth; then return 1; fi
    echo " > Zoraxy: Suppression Certificat $cert"
    api_req "/api/cert/delete" --data-urlencode "file=$cert" > /dev/null
    echo -e "${GREEN}‚úÖ Certificat supprim√©.${NC}"
}

# =======================================================
#  3. MODULE API INFOMANIAK
# =======================================================

create_infomaniak_record() {
    local source_sub="$1"; local target="$2"; local record_type="CNAME"

    # V√©rification Config
    if [ -z "$INFOMANIAK_TOKEN" ] || [ -z "$INFOMANIAK_DOMAIN" ]; then
        echo -e "${RED}‚ùå Erreur : Config Infomaniak manquante.${NC} Allez dans 'Configuration'."
        return 1
    fi

    if [[ "$target" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then record_type="A"; echo " > Infomaniak: D√©tection IP -> Mode 'A'"; else echo " > Infomaniak: D√©tection Domaine -> Mode 'CNAME'"; fi

    echo " > Infomaniak: Cr√©ation $record_type $source_sub -> $target..."
    JSON_DATA=$(jq -n --arg type "$record_type" --arg source "$source_sub" --arg target "$target" --arg ttl "3600" '{type: $type, source: $source, target: $target, ttl: $ttl|tonumber}')

    # Appel API Infomaniak
    RESPONSE=$(curl -s -X POST "https://api.infomaniak.com/1/domain/$INFOMANIAK_DOMAIN/dns/record" -H "Authorization: Bearer $INFOMANIAK_TOKEN" -H "Content-Type: application/json" -d "$JSON_DATA")

    STATUS=$(echo "$RESPONSE" | jq -r '.result')
    if [ "$STATUS" == "success" ]; then echo -e "${GREEN}‚úÖ DNS cr√©√©.${NC}"; return 0; else echo -e "${RED}‚ùå Erreur Infomaniak:${NC}"; echo "$RESPONSE" | jq -r '.error.description // .'; return 1; fi
}

delete_infomaniak_record() {
    local source_sub="$1"

    if [ -z "$INFOMANIAK_TOKEN" ] || [ -z "$INFOMANIAK_DOMAIN" ]; then
         echo -e "${RED}‚ùå Config Infomaniak manquante.${NC}"; return 1
    fi

    echo " > Infomaniak: Recherche ID pour $source_sub..."
    RECORD_ID=$(curl -s -X GET "https://api.infomaniak.com/1/domain/$INFOMANIAK_DOMAIN/dns/record" -H "Authorization: Bearer $INFOMANIAK_TOKEN" | jq -r --arg src "$source_sub" '.data[] | select(.source==$src) | .id' | head -n 1)

    if [ -n "$RECORD_ID" ] && [ "$RECORD_ID" != "null" ]; then
        echo " > Infomaniak: Suppression ID $RECORD_ID..."
        curl -s -X DELETE "https://api.infomaniak.com/1/domain/$INFOMANIAK_DOMAIN/dns/record/$RECORD_ID" -H "Authorization: Bearer $INFOMANIAK_TOKEN" > /dev/null
        echo -e "${GREEN}‚úÖ DNS supprim√©.${NC}"
    else echo -e "${YELLOW}‚ö†Ô∏è  Aucun enregistrement DNS trouv√©.${NC}"; fi
}

# =======================================================
#  4. GESTION DEPLOIEMENT & CONTENU
# =======================================================

handle_github_setup() {
    local target_dir="$1"; local github_url="$2"; local web_root_suffix=""
    echo -e "\n${BLUE}--- D√âPLOIEMENT GITHUB ---${NC}"
    if [ -d "$target_dir" ] && [ "$(ls -A "$target_dir")" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Dossier non vide. Nettoyage...${NC}"
        run_sudo rm -rf "$target_dir"/* "$target_dir"/.* 2>/dev/null
    fi
    echo "Clonage de $github_url..."
    if ! run_sudo git clone "$github_url" "$target_dir"; then echo -e "${RED}‚ùå √âchec Git.${NC}"; return 1; fi
    run_sudo chown -R $USER:www-data "$target_dir"

    if [ -f "$target_dir/composer.json" ]; then
        echo -e "\n${CYAN}üêò composer.json d√©tect√©.${NC}"
        if command -v composer &> /dev/null; then cd "$target_dir" && composer install --no-dev --optimize-autoloader
        else echo -e "${RED}‚ö†Ô∏è  Composer manquant.${NC}"; fi
    fi
    if [ -f "$target_dir/package.json" ]; then
        echo -e "\n${CYAN}üì¶ package.json d√©tect√©.${NC}"
        if command -v npm &> /dev/null; then cd "$target_dir" && npm install && npm run build 2>/dev/null || echo "Pas de script build."
        else echo -e "${RED}‚ö†Ô∏è  NPM manquant.${NC}"; fi
    fi

    echo -e "\n${YELLOW}üìÇ Racine Web (Web Root)${NC}"
    declare -a candidates; candidates+=("/")
    for d in public web dist html build; do [ -d "$target_dir/$d" ] && candidates+=("/$d"); done
    for i in "${!candidates[@]}"; do echo "  [$i] .${candidates[$i]}"; done
    read -p "Choix (0) : " root_sel
    if [[ "$root_sel" =~ ^[0-9]+$ ]] && [ "$root_sel" -le "${#candidates[@]}" ]; then
        web_root_suffix="${candidates[$root_sel]}"; [ "$web_root_suffix" == "/" ] && web_root_suffix=""
    else web_root_suffix=""; fi
    echo -e "${GREEN}‚úÖ Racine : $target_dir$web_root_suffix${NC}"
    run_sudo chown -R www-data:www-data "$target_dir"
    echo "$web_root_suffix" > /tmp/nginx_webroot_suffix
    return 0
}

perform_rollback() {
    echo -e "\n${RED}${BOLD}üö® ERREUR D√âTECT√âE - D√âBUT DU ROLLBACK AUTOMATIQUE${NC}"
    [ "$RB_ZORAXY" -eq 1 ] && { echo " üîô Zoraxy..."; delete_zoraxy_host "$VAL_FQDN"; }
    [ "$RB_DNS" -eq 1 ] && { echo " üîô DNS..."; delete_infomaniak_record "$VAL_SUB"; }
    [ "$RB_UFW" -eq 1 ] && { echo " üîô Firewall..."; run_sudo ufw delete allow "$RB_PORT/tcp" >/dev/null; }
    [ "$RB_NGINX" -eq 1 ] && { echo " üîô Nginx..."; run_sudo rm "$SITES_AVAIL/$VAL_FQDN.conf" 2>/dev/null; run_sudo rm "$SITES_ENAB/$VAL_FQDN.conf" 2>/dev/null; run_sudo systemctl reload nginx; }
    [ "$RB_FOLDER" -eq 1 ] && { echo " üîô Dossier..."; run_sudo rm -rf "$DIR_WEB/$VAL_FQDN"; }
    echo -e "${RED}‚ùå Op√©ration annul√©e et nettoyage effectu√©.${NC}"; pause
}

# --- NOYAU DE DEPLOIEMENT S√âCURIS√â ---
core_deployment_wizard() {
    local mode="$1"
    RB_FOLDER=0; RB_NGINX=0; RB_UFW=0; RB_DNS=0; RB_ZORAXY=0; RB_PORT=""

    # Check si la config existe
    if [ -z "$INFOMANIAK_DOMAIN" ]; then
        echo -e "${RED}‚ö†Ô∏è  Domaine non configur√©.${NC} Veuillez le configurer dans le menu principal."; pause; return
    fi

    # 1. NOM DE DOMAINE & VALIDATION
    echo -e "\n${BLUE}=== √âTAPE 1 : DOMAINE & SOURCE ===${NC}"
    while true; do
        read -p "Sous-domaine (ex: 'app') : " raw_input
        if [[ "$raw_input" =~ ^[a-zA-Z0-9._-]+$ ]]; then break; else echo -e "${RED}Caract√®res invalides. R√©essayez.${NC}"; fi
    done
    normalize_domain_input "$raw_input"
    echo -e "   -> Domaine complet : ${CYAN}$VAL_FQDN${NC}"

    # 2. SOURCE DU CONTENU
    echo -e "\n${YELLOW}Quelle est la source du projet ?${NC}"
    echo "1. Site Vierge (Page par d√©faut)"
    echo "2. Import GitHub (Clone + Build)"
    read -p "> " src_choice
    source_type="vierge"; github_url=""
    if [ "$src_choice" == "2" ]; then
        source_type="github"
        while [ -z "$github_url" ]; do read -p "URL du d√©p√¥t GitHub : " github_url; done
    fi

    # 3. PORT & VALIDATION DISPONIBILIT√â
    echo -e "\n${BLUE}=== √âTAPE 2 : CONFIGURATION R√âSEAU ===${NC}"
    while true; do
        read -p "Port Nginx Local (ex: 8081) : " port
        if [[ "$port" =~ ^[0-9]+$ ]] && [ "$port" -ge 1024 ] && [ "$port" -le 65535 ]; then
            if check_port_free "$port"; then
                echo -e "${GREEN}‚úÖ Port $port disponible.${NC}"
                RB_PORT="$port"
                break
            else echo -e "${RED}‚ùå Port $port d√©j√† utilis√©.${NC}"; fi
        else echo -e "${RED}Port invalide (1024-65535).${NC}"; fi
    done

    # 4. CIBLE DNS
    local default_target="$INFOMANIAK_DOMAIN"
    [ "$mode" == "lan" ] && default_target="$LOCAL_IP"
    echo -e "\nCible DNS (Entr√©e = ${GREEN}$default_target${NC}) :"
    read -p " > " dns_target
    [ -z "$dns_target" ] && dns_target="$default_target"
    if [[ ! "$dns_target" =~ ^[0-9]+ ]]; then [[ "$dns_target" != *.* ]] && dns_target="${dns_target}.${INFOMANIAK_DOMAIN}"; fi
    [[ "$dns_target" == "$VAL_FQDN" ]] && dns_target="$default_target"

    # 5. ACL ZORAXY
    SELECTED_ACL_ID=""; SELECTED_ACL_NAME="Aucune (Public)"
    if [ "$mode" == "lan" ]; then
        echo -e "\n${YELLOW}üîç Configuration ACL (R√©seau Local)${NC}"
        RAW_ACLS=$(get_zoraxy_acls)
        AUTO_ACL_ID=$(echo "$RAW_ACLS" | grep -iE "LAN|Local|Private" | head -n 1 | cut -d'|' -f1)
        AUTO_ACL_NAME=$(echo "$RAW_ACLS" | grep -iE "LAN|Local|Private" | head -n 1 | cut -d'|' -f2)
        if [ -n "$AUTO_ACL_ID" ]; then SELECTED_ACL_ID="$AUTO_ACL_ID"; SELECTED_ACL_NAME="$AUTO_ACL_NAME"; echo -e "‚úÖ ACL Automatique : ${GREEN}$SELECTED_ACL_NAME${NC}";
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Choisissez l'ACL :${NC}"
            declare -a ACL_IDS; declare -a ACL_NAMES; local i=1
            while IFS='|' read -r id name; do
                display_name="${name:-$id}"; echo "  $i. $display_name"; ACL_IDS+=("$id"); ACL_NAMES+=("$display_name"); ((i++))
            done <<< "$RAW_ACLS"
            read -p "Num√©ro ACL : " acl_idx
            if [[ "$acl_idx" =~ ^[0-9]+$ ]]; then SELECTED_ACL_ID="${ACL_IDS[$((acl_idx-1))]}"; SELECTED_ACL_NAME="${ACL_NAMES[$((acl_idx-1))]}"; fi
        fi
    fi

    # 6. SSL
    echo -e "\n${BLUE}=== √âTAPE 3 : S√âCURIT√â ===${NC}"
    echo "G√©n√©rer un certificat SSL (Let's Encrypt) ?"
    read -p " (o/n) > " ssl_choice

    # R√âSUM√â FINAL
    echo -e "\n${YELLOW}‚ïî‚ïê‚ïê‚ïê‚ïê R√âSUM√â DU D√âPLOIEMENT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${YELLOW}‚ïë${NC} Site       : ${CYAN}$VAL_FQDN${NC}"
    echo -e "${YELLOW}‚ïë${NC} Source     : $source_type"
    echo -e "${YELLOW}‚ïë${NC} Port       : $port"
    echo -e "${YELLOW}‚ïë${NC} Acc√®s      : $mode ($SELECTED_ACL_NAME)"
    echo -e "${YELLOW}‚ïë${NC} SSL        : $ssl_choice"
    echo -e "${YELLOW}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"

    read -p "Confirmer le d√©ploiement ? (o/n) : " c; if [ "$c" != "o" ]; then return; fi

    # --- EXECUTION ---

    echo -e "\n${BOLD}[1/6] Installation du contenu...${NC}"
    if ! ask_sudo_gui; then return; fi

    docroot="$DIR_WEB/$VAL_FQDN"
    if [ ! -d "$docroot" ]; then run_sudo mkdir -p "$docroot"; RB_FOLDER=1; fi

    WEB_ROOT_SUFFIX=""
    if [ "$source_type" == "github" ]; then
        handle_github_setup "$docroot" "$github_url"
        if [ $? -ne 0 ]; then perform_rollback; return; fi
        WEB_ROOT_SUFFIX=$(cat /tmp/nginx_webroot_suffix 2>/dev/null); rm /tmp/nginx_webroot_suffix 2>/dev/null
    else
        echo "<h1>Site $VAL_FQDN</h1><p>Mode: $mode</p>" | run_sudo tee "$docroot/index.html" >/dev/null
        run_sudo chown -R www-data:www-data "$docroot"
    fi

    echo -e "\n${BOLD}[2/6] Configuration Nginx...${NC}"
    conf="$SITES_AVAIL/$VAL_FQDN.conf"
    if [ -f "$conf" ]; then echo -e "${YELLOW}‚ö†Ô∏è  Fichier conf existant √©cras√©.${NC}"; fi

    cat <<EOF | run_sudo tee "$conf" > /dev/null
server {
    listen $port;
    server_name $VAL_FQDN _;
    root $docroot$WEB_ROOT_SUFFIX;
    index index.html index.php;
    absolute_redirect off;
    access_log /var/log/nginx/${VAL_SUB}_access.log;
    error_log /var/log/nginx/${VAL_SUB}_error.log;
    location / { try_files \$uri \$uri/ =404; }
}
EOF
    RB_NGINX=1
    run_sudo ln -sf "$conf" "$SITES_ENAB/$VAL_FQDN.conf"
    if ! run_sudo systemctl reload nginx; then echo "Erreur Reload Nginx"; perform_rollback; return; fi

    echo -e "${BOLD}[3/6] Firewall...${NC}"; run_sudo ufw allow "$port/tcp" >/dev/null; RB_UFW=1
    echo -e "${BOLD}[4/6] DNS...${NC}"; create_infomaniak_record "$VAL_SUB" "$dns_target"; if [ $? -ne 0 ]; then perform_rollback; return; fi; RB_DNS=1
    echo -e "${BOLD}[5/6] Zoraxy...${NC}"; add_zoraxy_host "$VAL_FQDN" "$LOCAL_IP:$port" "$SELECTED_ACL_ID"; if [ $? -ne 0 ]; then perform_rollback; return; fi; RB_ZORAXY=1

    if [[ "$ssl_choice" == "o" || "$ssl_choice" == "O" || "$ssl_choice" == "y" ]]; then
        echo -e "${BOLD}[6/6] SSL...${NC}"; request_zoraxy_ssl "$VAL_FQDN"
    else echo -e "${BOLD}[6/6] SSL ignor√©.${NC}"; fi

    echo -e "\n${GREEN}üéâ Termin√© ! Site en ligne.${NC}"
    read -p "√âditer Nginx maintenant ? (o/n) " ed
    if [ "$ed" == "o" ]; then run_sudo nano "$conf"; run_sudo systemctl reload nginx; fi
    pause
}

wizard_link_orphan_site() {
    echo -e "\n${BLUE}=== LIER UN SITE EXISTANT √Ä ZORAXY ===${NC}"
    if ! ensure_zoraxy_auth; then return; fi

    echo "Recherche des sites non li√©s..."

    # 1. R√©cup√©ration ROBUSTE des ports utilis√©s par Zoraxy
    # On r√©cup√®re toutes les origines, on prend ce qui est apr√®s le dernier ':', et on garde que les chiffres
    Z_PORTS_LIST=$(api_req "/api/proxy/list" --data-urlencode "type=host" | jq -r 'to_entries[] | .value.ActiveOrigins[0].OriginIpOrDomain' | sed 's/.*://' | grep -oE "[0-9]+")

    # On convertit en une seule ligne avec des espaces pour la recherche (ex: " 8000 8080 8081 ")
    Z_PORTS_STRING=" $(echo "$Z_PORTS_LIST" | tr '\n' ' ') "

    declare -a ORPHAN_FILES
    declare -a ORPHAN_PORTS
    declare -a ORPHAN_NAMES

    idx=0

    # 2. Scanner Nginx
    shopt -s nullglob
    for f in "$SITES_AVAIL"/*; do
        content=$(sudo cat "$f" 2>/dev/null)
        # Extraction du port Nginx
        port=$(echo "$content" | grep -E "^\s*listen" | grep -oE "[0-9]+" | head -n1)
        # Extraction du nom de serveur (pour info)
        server_name=$(echo "$content" | grep "server_name" | awk '{print $2}' | sed 's/;//')

        if [ -n "$port" ]; then
            # LA CORRECTION EST ICI : On v√©rifie si le port est pr√©sent dans la chaine Z_PORTS_STRING
            if [[ "$Z_PORTS_STRING" != *" $port "* ]]; then
                ORPHAN_FILES[$idx]="$f"
                ORPHAN_PORTS[$idx]="$port"
                ORPHAN_NAMES[$idx]="${server_name:-Inconnu}"
                ((idx++))
            # Debug (Optionnel, √† commenter si trop verbeux)
            # else echo "DEBUG: Le site $server_name sur le port $port est bien d√©tect√© comme li√©."
            fi
        fi
    done
    shopt -u nullglob

    if [ $idx -eq 0 ]; then
        echo -e "${GREEN}‚úÖ Tous vos sites Nginx sont d√©j√† li√©s √† Zoraxy !${NC}"
        pause
        return
    fi

    # 3. Afficher la liste
    echo -e "${YELLOW}Sites Nginx d√©tect√©s sans Proxy Zoraxy :${NC}"
    for ((i=0; i<idx; i++)); do
        fname=$(basename "${ORPHAN_FILES[$i]}")
        echo -e "  ${GREEN}$((i+1)).${NC} $fname (Port: ${ORPHAN_PORTS[$i]}) - Domaine actuel: ${ORPHAN_NAMES[$i]}"
    done

    echo ""
    read -p "S√©lectionnez le site √† lier (0=Retour) > " sel

    if [[ ! "$sel" =~ ^[0-9]+$ ]] || [ "$sel" -lt 1 ] || [ "$sel" -gt "$idx" ]; then
        return
    fi

    sel_idx=$((sel-1))
    TARGET_PORT="${ORPHAN_PORTS[$sel_idx]}"
    CURRENT_NAME="${ORPHAN_NAMES[$sel_idx]}"

    echo -e "\n${BLUE}--- CONFIGURATION ZORAXY ---${NC}"

    # 4. Demander le domaine public
    echo -e "Domaine actuel dans Nginx : ${CYAN}$CURRENT_NAME${NC}"
    read -p "Domaine Public pour Zoraxy (Entr√©e pour conserver '$CURRENT_NAME') : " input_domain
    if [ -z "$input_domain" ]; then input_domain="$CURRENT_NAME"; fi

    if [ "$input_domain" == "_" ] || [ -z "$input_domain" ]; then
        read -p "Domaine invalide. Entrez un domaine (ex: site.mondomaine.fr) : " input_domain
    fi
    VAL_FQDN="$input_domain"

    # 5. Demander ACL
    echo -e "\n${YELLOW}Type d'acc√®s (ACL) ?${NC}"
    echo "1. üåç Public (Internet)"
    echo "2. üè† Priv√© (LAN seulement)"
    read -p "> " acl_choice

    SELECTED_ACL_ID=""
    if [ "$acl_choice" == "2" ]; then
        RAW_ACLS=$(get_zoraxy_acls)
        AUTO_ACL_ID=$(echo "$RAW_ACLS" | grep -iE "LAN|Local|Private" | head -n 1 | cut -d'|' -f1)
        if [ -n "$AUTO_ACL_ID" ]; then
            SELECTED_ACL_ID="$AUTO_ACL_ID"
            echo -e "‚úÖ ACL LAN d√©tect√©e automatiquement."
        else
            echo "${RED}Pas d'ACL LAN trouv√©e. Site sera Public.${NC}"
        fi
    fi

    # 6. Ex√©cution
    echo -e "\n${BOLD}Liaison en cours...${NC}"
    add_zoraxy_host "$VAL_FQDN" "127.0.0.1:$TARGET_PORT" "$SELECTED_ACL_ID"

    if [ $? -eq 0 ]; then
        echo -e "\n${GREEN}üéâ Site li√© avec succ√®s !${NC}"
        read -p "Voulez-vous g√©n√©rer un certificat SSL maintenant ? (o/n) " ssl_q
        if [ "$ssl_q" == "o" ]; then
            request_zoraxy_ssl "$VAL_FQDN"
        fi
    fi
    pause
}

wizard_new_site_menu() {
    clear
    echo -e "${BLUE}################################################${NC}"
    echo -e "${BLUE}#           CR√âATION D'UN NOUVEAU SITE         #${NC}"
    echo -e "${BLUE}################################################${NC}"
    echo "Que souhaitez-vous faire ?"
    echo ""
    echo -e "${GREEN}1. üåç CR√âER UN SITE PUBLIC (INTERNET)${NC}"
    echo -e "   ${GREY}Exemple : blog.monsite.fr -> Cr√©e Dossier + Nginx + Zoraxy${NC}"
    echo ""
    echo -e "${YELLOW}2. üè† CR√âER UN SITE PRIV√â (R√âSEAU LOCAL)${NC}"
    echo -e "   ${GREY}Exemple : nas.monsite.fr -> Accessible uniquement en LAN${NC}"
    echo ""
    echo -e "${CYAN}3. üîó LIER UN SITE EXISTANT (NON LI√â)${NC}"
    echo -e "   ${GREY}Pour les sites Nginx existants qui n'apparaissent pas dans Zoraxy.${NC}"
    echo ""
    echo -e "${RED}0. Retour${NC}"

    read -p "Votre choix > " access_type

    case "$access_type" in
        1) core_deployment_wizard "public" ;;
        2)
            echo -e "\n${YELLOW}--- Options Site Priv√© ---${NC}"
            echo "1. Avec Nom de Domaine (Recommand√©)"
            echo "2. Par IP Directe (Simple)"
            read -p "> " sub
            [ "$sub" == "1" ] && core_deployment_wizard "lan"
            [ "$sub" == "2" ] && create_simple_vhost_wizard
            ;;
        3) wizard_link_orphan_site ;; # <--- NOUVELLE APPEL
    esac
}

create_simple_vhost_wizard() {
    echo -e "\n${GREEN}‚ûï SITE SIMPLE (IP:PORT)${NC}"
    echo "Ce site sera accessible via http://$LOCAL_IP:PORT"
    read -p "Nom du projet : " d; [ -z "$d" ] && return

    # Check port
    while true; do
        read -p "Port : " port
        if check_port_free "$port"; then break; else echo "${RED}Port occup√©.${NC}"; fi
    done

    if ! ask_sudo_gui; then return; fi
    # Note: setup_site_content was missing in original script source, using generic creation
    run_sudo mkdir -p "$DIR_WEB/$d"
    echo "<h1>Site Local $d</h1>" | run_sudo tee "$DIR_WEB/$d/index.html" >/dev/null
    run_sudo chown -R www-data:www-data "$DIR_WEB/$d"

    conf="$SITES_AVAIL/$d.conf"
    cat <<EOF | run_sudo tee "$conf" > /dev/null
server {
    listen $port;
    server_name _;
    root $DIR_WEB/$d;
    index index.html;
    absolute_redirect off;
}
EOF
    run_sudo ln -sf "$conf" "$SITES_ENAB/$d.conf"
    run_sudo ufw allow "$port/tcp" >/dev/null
    run_sudo systemctl reload nginx
    echo -e "\n${GREEN}‚úÖ Site actif.${NC}"; pause
}

# --- ACTIONS SUPPLEMENTAIRES ---

action_toggle_vhost() {
    refresh_dashboard_table; read -p "Site # (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"; bn=$(basename "$f")
    if ask_sudo_gui; then
        if ls "$SITES_ENAB/$bn"* 1>/dev/null 2>&1; then run_sudo rm "$SITES_ENAB/$bn"*; echo -e "${RED}üî¥ D√©sactiv√©.${NC}"; else run_sudo ln -sf "$f" "$SITES_ENAB/$bn"; echo -e "${GREEN}üü¢ Activ√©.${NC}"; fi
        run_sudo systemctl reload nginx; pause
    fi
}

action_edit_vhost() {
    refresh_dashboard_table; read -p "Site # (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"
    if ask_sudo_gui; then
        run_sudo cp "$f" "$f.bak_tmp"; run_sudo nano "$f"
        if run_sudo nginx -t; then run_sudo rm "$f.bak_tmp"; run_sudo systemctl reload nginx; else echo "${RED}Erreur Syntaxe!${NC}"; run_sudo mv "$f.bak_tmp" "$f"; fi
        pause
    fi
}

action_ssl_retry() {
    refresh_dashboard_table; read -p "Site # (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"; filename=$(basename "$f"); domain_conf="${filename%.*}"
    request_zoraxy_ssl "$domain_conf"; pause
}

action_cleanup_ssl() {
    echo -e "\n${BLUE}### NETTOYAGE CERTIFICATS (ZORAXY) ###${NC}"
    if ! ensure_zoraxy_auth; then return; fi
    echo "Analyse en cours..."

    # R√©cup√©ration de la liste des certificats (API retourne les noms sans extensions)
    # On utilise jq -r pour avoir une liste propre
    CERTS_RAW=$(api_req "/api/cert/list" | jq -r 'if type=="array" then .[] else keys[] end')

    # R√©cup√©ration des h√¥tes actifs pour comparer
    ACTIVE_HOSTS=$(api_req "/api/proxy/list" --data-urlencode "type=host" | jq -r 'to_entries[] | "\(.value.RootOrMatchingDomain)"')

    if [ -z "$CERTS_RAW" ]; then echo "Aucun certificat trouv√©."; pause; return; fi

    declare -a CERT_FILES; declare -a CERT_STATUS_TXT; declare -a CERT_LINKS_TXT; declare -a CERT_COLOR; declare -a SELECTED; idx=0

    # Mise en forme du tableau
    MAX_LEN=20
    for cert in $CERTS_RAW; do len=${#cert}; if (( len > MAX_LEN )); then MAX_LEN=$len; fi; done
    MAX_LEN=$((MAX_LEN + 2))

    for cert in $CERTS_RAW; do
        # On nettoie au cas o√π, mais l'API Zoraxy semble renvoyer le nom pur
        cert_name="${cert%.pem}"; cert_name="${cert_name%.crt}"
        [[ "$cert_name" == "server" || "$cert_name" == "ca" || "$cert_name" == "null" ]] && continue

        CERT_FILES[$idx]="$cert_name"
        is_used=0
        linked_host="-"

        if echo "$ACTIVE_HOSTS" | grep -qx "$cert_name"; then
            is_used=1; linked_host="$cert_name"
        elif [[ "$cert_name" == *"_"* || "$cert_name" == *"wildcard"* ]]; then
            is_used=1; linked_host="Wildcard/Autre"
        fi

        if [ $is_used -eq 1 ]; then
            CERT_STATUS_TXT[$idx]="UTILIS√â"; CERT_COLOR[$idx]=$GREEN; CERT_LINKS_TXT[$idx]="$linked_host"; SELECTED[$idx]=0
        else
            CERT_STATUS_TXT[$idx]="ORPHELIN"; CERT_COLOR[$idx]=$RED; CERT_LINKS_TXT[$idx]="Aucun"; SELECTED[$idx]=1
        fi
        ((idx++))
    done

    # Boucle d'affichage
    while true; do
        clear; echo -e "${BLUE}=== GESTION SSL (Zoraxy) ===${NC}"
        printf "%-4s %-5s %-${MAX_LEN}s %-15s %-30s\n" "N¬∞" "DEL" "DOMAINE" "√âTAT" "SITE LI√â"
        echo "--------------------------------------------------------------------------------"
        for ((i=0; i<idx; i++)); do
            if [ "${SELECTED[$i]}" -eq 1 ]; then t_mark="[X]"; c_mark="$RED"; else t_mark="[ ]"; c_mark=""; fi
            printf "%-4s %b%-5s%b %-${MAX_LEN}s %b%-15s%b %b%-30s%b\n" \
                "$((i+1))" "$c_mark" "$t_mark" "$NC" "${CERT_FILES[$i]}" "${CERT_COLOR[$i]}" "${CERT_STATUS_TXT[$i]}" "$NC" "$GREY" "${CERT_LINKS_TXT[$i]}" "$NC"
        done
        echo -e "\n [N¬∞] Cocher/D√©cocher | [v] Valider suppression | [0] Annuler"
        read -p "> " input

        if [ "$input" == "0" ]; then return; fi
        if [ "$input" == "v" ]; then break; fi
        if [[ "$input" =~ ^[0-9]+$ ]] && [ "$input" -ge 1 ] && [ "$input" -le "$idx" ]; then
            r=$((input-1)); if [ "${SELECTED[$r]}" -eq 1 ]; then SELECTED[$r]=0; else SELECTED[$r]=1; fi
        fi
    done

    # Ex√©cution de la suppression
    count=0
    echo ""
    for ((i=0; i<idx; i++)); do
        if [ "${SELECTED[$i]}" -eq 1 ]; then
            domain_to_del="${CERT_FILES[$i]}"
            echo -n "Suppression de $domain_to_del... "

            # --- CORRECTION ICI : Param√®tre 'domain' ---
            api_req "/api/cert/delete" -X POST --data-urlencode "domain=$domain_to_del" > /dev/null

            echo "OK"
            ((count++))
        fi
    done
    echo -e "${GREEN}$count certificats supprim√©s.${NC}"; check_zoraxy_health; pause
}

action_delete_wizard() {
    refresh_dashboard_table; read -p "Site # √† SUPPRIMER (0=Retour) : " sel; [ "$sel" == "0" ] && return

    f="${VHOST_FILES[$((sel-1))]}"; filename=$(basename "$f")
    content=$(sudo cat "$f" 2>/dev/null)
    domain_conf=$(echo "$content" | grep "server_name" | awk '{print $2}' | sed 's/;//')
    if [ "$domain_conf" == "_" ]; then domain_conf="${filename%.*}"; fi
    target_port=$(echo "$content" | grep -E "^\s*listen" | grep -oE "[0-9]+" | head -n1)
    normalize_domain_input "$domain_conf"

    echo -e "\n${RED}${BOLD}üóëÔ∏è  SUPPRESSION DE : $domain_conf${NC}"
    echo "Analyse des ressources associ√©es..."

    d_web="NON"
    if [ -d "$DIR_WEB/$domain_conf" ]; then d_web="${RED}OUI ($DIR_WEB/$domain_conf)${NC}"; has_web=1; else d_web="${GREEN}NON${NC}"; has_web=0; fi

    d_proxy="NON"; has_proxy=0
    if check_zoraxy_health; then
        if api_req "/api/proxy/list" --data-urlencode "type=host" | grep -q "$VAL_FQDN"; then d_proxy="${RED}OUI (Proxy Actif)${NC}"; has_proxy=1; else d_proxy="${GREEN}NON${NC}"; fi
    fi

    d_cert="NON"; has_cert=0
    if check_zoraxy_health; then
        if api_req "/api/cert/list" | grep -q "$VAL_FQDN"; then d_cert="${RED}OUI (Certificat trouv√©)${NC}"; has_cert=1; else d_cert="${GREEN}NON${NC}"; fi
    fi

    echo -e "\n${YELLOW}Ressources trouv√©es :${NC}"
    echo -e " - Config Nginx : ${RED}OUI ($filename)${NC}"
    echo -e " - Dossier Web  : $d_web"
    echo -e " - Proxy Zoraxy : $d_proxy"
    echo -e " - Certificat   : $d_cert"
    echo -e " - Entr√©e DNS   : ${RED}OUI (Infomaniak)${NC}"

    echo -e "\n${BOLD}Que voulez-vous faire ?${NC}"
    del_web="n"; del_proxy="n"; del_cert="n"; del_dns="n"

    if [ $has_web -eq 1 ]; then read -p " > Supprimer le dossier web ? (o/n) " del_web; fi
    if [ $has_proxy -eq 1 ]; then read -p " > Supprimer le Proxy Zoraxy ? (o/n) " del_proxy; fi
    if [ $has_cert -eq 1 ]; then read -p " > Supprimer le Certificat SSL ? (o/n) " del_cert; fi
    read -p " > Supprimer l'entr√©e DNS Infomaniak ? (o/n) " del_dns

    echo -e "\n${RED}CONFIRMATION FINALE${NC}"
    read -p "Tapez 'oui' pour ex√©cuter la suppression : " confirm
    if [ "$confirm" != "oui" ]; then echo "Annul√©."; pause; return; fi

    if ! ask_sudo_gui; then return; fi

    echo ""
    if [ "$del_dns" == "o" ]; then delete_infomaniak_record "$VAL_SUB"; fi
    if [ "$del_proxy" == "o" ]; then delete_zoraxy_host "$VAL_FQDN"; fi
    if [ "$del_cert" == "o" ]; then delete_zoraxy_cert "$VAL_FQDN.pem"; fi

    [ -n "$target_port" ] && run_sudo ufw delete allow "$target_port/tcp" >/dev/null

    echo "Suppression Nginx..."
    target_link=$(find "$SITES_ENAB" -name "$filename*"); [ -n "$target_link" ] && run_sudo rm "$target_link"
    run_sudo rm "$f"; run_sudo systemctl reload nginx

    if [ "$del_web" == "o" ]; then
        echo "Suppression Dossier..."
        run_sudo rm -rf "$DIR_WEB/$domain_conf"
    fi
    echo -e "${GREEN}Termin√©.${NC}"; pause
}

# =======================================================
#  6. DASHBOARD & GESTION SITES
# =======================================================

declare -a VHOST_FILES

refresh_dashboard_table() {
    VHOST_FILES=()
    shopt -s nullglob
    local files=("$SITES_AVAIL"/*)
    shopt -u nullglob

    # On r√©cup√®re la liste des proxies Zoraxy
    if check_zoraxy_health; then
        Z_PROXIES=$(api_req "/api/proxy/list" --data-urlencode "type=host" | jq -r 'to_entries[] | select(.value | type == "object") | "\(.value.ActiveOrigins[0].OriginIpOrDomain // "null")|\(.value.RootOrMatchingDomain)|\(.value.UseTLS)"')
    else
        Z_PROXIES=""
    fi

    echo -e "${BLUE}=== TABLEAU DE BORD DES SITES WEB ===${NC}"
    printf "%-3s %-45s %-8s %-40s %-20s\n" "ID" "DOMAINE PUBLIC (ZORAXY)" "PORT" "RACINE WEB" "S√âCURIT√â"
    echo "-----------------------------------------------------------------------------------------------------------------------"

    if [ ${#files[@]} -eq 0 ]; then
        echo "   (Aucun site configur√©)"
    else
        local i=1
        for f in "${files[@]}"; do
            VHOST_FILES+=("$f")

            # Lecture Config Nginx
            content=$(sudo cat "$f" 2>/dev/null)
            port=$(echo "$content" | grep -E "^\s*listen" | grep -oE "[0-9]+" | head -n1)
            [ -z "$port" ] && port="-"
            root_dir=$(echo "$content" | grep -E "^\s*root" | awk '{print $2}' | sed 's/;//')

            zoraxy_host_txt="Non li√©"
            ssl_status_txt="-"
            c_host=$GREY
            c_ssl=$GREY

            if [ -n "$port" ] && [ "$port" != "-" ]; then
                # Recherche stricte du port dans la liste Zoraxy
                z_match=$(echo "$Z_PROXIES" | grep -F ":$port|")

                if [ -n "$z_match" ]; then
                    IFS='|' read -r z_origin z_domain z_tls <<< "$z_match"
                    zoraxy_host_txt="$z_domain"
                    c_host=$CYAN

                    if [ "$z_tls" == "true" ]; then
                        ssl_status_txt="üîí G√©r√© par Zoraxy"
                        c_ssl=$GREEN
                    else
                        ssl_status_txt="üîì Non S√©curis√©"
                        c_ssl=$YELLOW
                    fi
                fi
            fi

            # Formatage pour alignement
            d_dom="${zoraxy_host_txt:0:44}"
            d_root="${root_dir:0:39}"

            printf "%-3s %b%-45s%b %-8s %-40s %b%-20s%b\n" \
                "$i" "$c_host" "$d_dom" "$NC" "$port" "$d_root" "$c_ssl" "$ssl_status_txt" "$NC"
            ((i++))
        done
    fi
    echo "-----------------------------------------------------------------------------------------------------------------------"
}

menu_ssl_manager() {
    while true; do
        clear
        echo -e "${BLUE}################################################${NC}"
        echo -e "${BLUE}#         üîê GESTION DES CERTIFICATS           #${NC}"
        echo -e "${BLUE}################################################${NC}"
        echo ""
        echo -e "  ${GREEN}1.${NC} üîÑ Renouveler / Forcer un certificat"
        echo -e "     ${GREY}(Utile si un site affiche 'Non s√©curis√©' ou si le certificat a expir√©)${NC}"
        echo ""
        echo -e "  ${RED}2.${NC} üßπ Nettoyer / Supprimer des certificats"
        echo -e "     ${GREY}(Supprimer les vieux certificats orphelins via une liste)${NC}"
        echo ""
        echo -e "  ${RED}0.${NC} Retour"
        echo ""

        read -p "Votre choix > " c
        case "$c" in
            1) action_ssl_retry ;;
            2) action_cleanup_ssl ;;
            0) return ;;
            *) echo "Choix invalide"; sleep 1 ;;
        esac
    done
}

manage_nginx_sites_menu() {
    while true; do
        clear
        refresh_dashboard_table
        echo ""
        echo -e " ${BOLD}--- ACTIONS ---${NC}"
        echo -e "  ${GREEN}1.${NC} ‚ûï Ajouter un site"
        echo -e "  ${YELLOW}2.${NC} ‚èØÔ∏è  Activer / D√©sactiver"
        echo -e "  ${CYAN}3.${NC} üìù Modifier (Config Nginx)"
        echo -e "  ${RED}4.${NC} üóëÔ∏è  Supprimer"
        echo ""
        echo -e " ${BOLD}--- S√âCURIT√â ---${NC}"
        echo -e "  ${BLUE}5.${NC} üîê Gestion des certificats (Renouveler ou Supprimer)"
        echo ""
        echo -e "  ${RED}0.${NC} üîô Retour au Menu Principal"

        read -r -p "  Votre choix > " ch
        case "$ch" in
            1) wizard_new_site_menu ;;
            2) action_toggle_vhost ;;
            3) action_edit_vhost ;;
            4) action_delete_wizard ;;
            5) menu_ssl_manager ;;
            0) break ;;
            *) echo "Choix invalide"; sleep 1 ;;
        esac
    done
}

# =======================================================
#  7. MENU SYSTEME & LOOP
# =======================================================

firewall_manager() {
    while true; do
        clear; echo -e "${BLUE}=== GESTION PARE-FEU ===${NC}"
        run_sudo ufw status numbered
        echo -e "1. Ouvrir Port | 2. Supprimer R√®gle | 0. Retour"
        read -r -p "> " c
        case "$c" in
            1) read -p "Port: " p; [ -n "$p" ] && ask_sudo_gui && run_sudo ufw allow "$p"; pause ;;
            2) read -p "Num√©ro: " n; [ -n "$n" ] && ask_sudo_gui && echo "y" | run_sudo ufw delete "$n"; pause ;;
            0) return ;;
        esac
    done
}

backup_menu() {
    while true; do
        clear; echo -e "${BLUE}=== BACKUP ===${NC}"
        ls -lh "$BACKUP_DIR" 2>/dev/null | grep "tar.gz"
        echo "1. Backup Full Nginx | 0. Retour"
        read -r -p "> " c
        if [ "$c" == "1" ] && ask_sudo_gui; then
            run_sudo mkdir -p "$BACKUP_DIR"
            run_sudo tar -czf "$BACKUP_DIR/NGINX_FULL_$(date +%Y%m%d).tar.gz" "$NGINX_HOME" "$DIR_WEB"
            echo "Backup cr√©√©."; pause
        elif [ "$c" == "0" ]; then return; fi
    done
}

while true; do
    clear; ensure_requirements; get_sys_info

    echo -e "${BLUE}################################################${NC}"
    echo -e "${BLUE}#           MANAGER SERVEUR WEB                #${NC}"
    echo -e "${BLUE}################################################${NC}"

    printf "  üñ•Ô∏è  %-21s | üîå Service : %-12b\n" "${CYAN}$OS_NAME${NC}" "$SX"
    printf "  üè† LAN: %-15s | üåç WAN: %s\n" "${YELLOW}$LOCAL_IP${NC}" "${YELLOW}$PUBLIC_IP${NC}"
    echo -e "$SEP"
    # --- NOUVEAU BLOC STATS ---
    printf "  üß† RAM : %-15s | ‚ö° CPU : %s\n" "${CYAN}$RAM_USAGE${NC}" "${CYAN}$CPU_USAGE${NC}"
    printf "  üõ°Ô∏è  FW  : %-15s | üåê Sites Actifs : ${GREEN}%s${NC}\n" "$FW" "$SITES_COUNT"
    echo -e "$SEP"

    echo -e " ${BOLD}${CYAN}‚ö° GESTION DU SERVICE${NC}"
    echo -e "    ${GREEN}1.${NC} ‚ñ∂Ô∏è  D√©marrer le service"
    echo -e "    ${GREEN}2.${NC} ‚èπÔ∏è  Arr√™ter le service"
    echo -e "    ${GREEN}3.${NC} üîÑ Red√©marrer le service"
    echo -e "    ${GREEN}4.${NC} üìú Logs du service"
    echo ""
    echo -e " ${BOLD}${CYAN}üåê SITES & D√âPLOIEMENT${NC}"
    echo -e "    ${GREEN}5.${NC} üåê Gestion des Sites Web (Dashboard)"
    echo -e "    ${GREEN}6.${NC} ‚öôÔ∏è  Configuration (Infomaniak / Zoraxy)"
    echo ""
    echo -e " ${BOLD}${CYAN}üõ°Ô∏è  S√âCURIT√â & MAINTENANCE${NC}"
    echo -e "    ${GREEN}7.${NC} üß± Pare-feu (UFW)"
    echo -e "    ${GREEN}9.${NC} üíæ Sauvegardes"
    echo -e "    ${GREEN}10.${NC}üöÄ Mises √† jour Syst√®me"
    echo -e "$SEP_RED"
    echo -e " ${BOLD}${RED}üíÄ ZONES SYST√àME${NC}"
    echo -e "    ${RED}11.${NC}üîå √âteindre le serveur"
    echo -e "    ${RED}12.${NC}‚ôªÔ∏è  Red√©marrer le serveur"
    echo -e "$SEP"
    echo -e "  [${RED}exit${NC}] üö™ Quitter"
    echo -e "$SEP"

    read -r -p "  Votre choix > " ch

    case "$ch" in
        1) ask_sudo_gui && run_sudo systemctl start nginx; pause ;;
        2) ask_sudo_gui && run_sudo systemctl stop nginx; pause ;;
        3) ask_sudo_gui && run_sudo systemctl restart nginx; pause ;;
        4) run_sudo tail -f "$LOG_ERROR" ;;
        5) manage_nginx_sites_menu ;;
        6) settings_menu ;;
        7) firewall_manager ;;
        9) backup_menu ;;
        10) ask_sudo_gui && sudo apt update && sudo apt upgrade -y; pause ;;
        11) ask_sudo_gui && sudo poweroff ;;
        12) ask_sudo_gui && sudo reboot ;;
        exit|q) exit 0 ;;
        *) echo "Choix invalide"; sleep 1 ;;
    esac
done
