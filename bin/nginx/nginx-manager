#!/bin/bash
# ===========================
#  MANAGER SERVEUR WEB
# ===========================

# --- CONFIGURATION UTILISATEUR ---
INFOMANIAK_TOKEN=""
INFOMANIAK_DOMAIN_ID=""
ZORAXY_PORT="8000"

# --- CONFIGURATION SYSTEME ---
DIR_WEB="/var/www"
NGINX_HOME="/etc/nginx"
SITES_AVAIL="$NGINX_HOME/sites-available"
SITES_ENAB="$NGINX_HOME/sites-enabled"
BACKUP_DIR="/var/backups/nginx-manager"
LOG_ACCESS="/var/log/nginx/access.log"
LOG_ERROR="/var/log/nginx/error.log"

# --- CONFIGURATION ZORAXY (LAN) ---
ZORAXY_API_URL="http://192.168.1.30:$ZORAXY_PORT"
COOKIE_FILE="/tmp/zoraxy_cookie_manager.txt"

# --- CACHE & UTILITAIRES ---
PUBLIC_IP_CACHE="/tmp/nginx_public_ip"
CMD_NGINX="/usr/sbin/nginx"
CMD_UFW="/usr/sbin/ufw"

# --- S√âCURIT√â & COULEURS ---
trap '' SIGINT SIGQUIT SIGTSTP
BLUE=$'\033[0;34m'
GREEN=$'\033[0;32m'
RED=$'\033[0;31m'
YELLOW=$'\033[1;33m'
CYAN=$'\033[0;36m'
GREY=$'\033[1;30m'
NC=$'\033[0m'
BOLD=$'\033[1m'

# =======================================================
#  1. FONCTIONS SYST√àME DE BASE
# =======================================================

ask_sudo_gui() {
    if sudo -n true 2>/dev/null; then return 0; fi
    echo -e "\n${YELLOW}üîí Authentification requise${NC}"
    read -s -p "Mot de passe : " user_pass
    echo ""
    echo "$user_pass" | sudo -S -v 2>/dev/null
    if [ $? -eq 0 ]; then return 0; else echo -e "${RED}‚ùå Incorrect.${NC}"; pause; return 1; fi
}

run_sudo() {
    if sudo -n true 2>/dev/null; then sudo "$@"; return $?; fi
    if ! ask_sudo_gui; then return 1; fi
    sudo "$@"
}

run_sudo_silent() {
    sudo -n "$@" 2>/dev/null
}

pause() {
    echo ""
    read -p "Appuyez sur Entr√©e pour continuer..."
}

ensure_requirements() {
    if ! command -v jq &> /dev/null; then echo -e "${RED}Erreur: 'jq' requis.${NC}"; exit 1; fi
    if ! command -v curl &> /dev/null; then echo -e "${RED}Erreur: 'curl' requis.${NC}"; exit 1; fi
    if ! command -v git &> /dev/null; then echo -e "${RED}Erreur: 'git' requis.${NC}"; exit 1; fi
}

get_sys_info() {
    LOCAL_IP=$(hostname -I | awk '{print $1}')
    if [ -f "$PUBLIC_IP_CACHE" ] && [ $(( $(date +%s) - $(stat -c %Y "$PUBLIC_IP_CACHE") )) -lt 3600 ]; then
        PUBLIC_IP=$(cat "$PUBLIC_IP_CACHE")
    else
        PUBLIC_IP=$(curl -s -4 -m 3 https://icanhazip.com 2>/dev/null)
        [[ "$PUBLIC_IP" =~ ^[0-9.]+$ ]] && echo "$PUBLIC_IP" > "$PUBLIC_IP_CACHE" || PUBLIC_IP="N/A"
    fi
    OS_NAME=$(grep -oP 'PRETTY_NAME="\K[^"]+' /etc/os-release 2>/dev/null | cut -c1-20)
    [ -z "$OS_NAME" ] && OS_NAME="Linux"
    APP_VER=$($CMD_NGINX -v 2>&1 | awk -F/ '{print $2}')
    
    if systemctl is-active --quiet nginx; then SX="${GREEN}‚óè ON${NC}"; else SX="${RED}‚óè OFF${NC}"; fi
    if run_sudo_silent $CMD_UFW status 2>/dev/null | grep -q "active"; then FW="${GREEN}‚óè ACTIF${NC}"; else FW="${RED}‚óè INACTIF${NC}"; fi
}

normalize_domain_input() {
    local input="$1"
    local base="$INFOMANIAK_DOMAIN_ID"
    input="${input%.}" 
    if [[ "$input" == *"$base" ]]; then
        VAL_FQDN="$input"
        VAL_SUB="${input%.$base}"
    else
        VAL_SUB="$input"
        VAL_FQDN="${input}.${base}"
    fi
}

# =======================================================
#  2. MODULE API ZORAXY
# =======================================================

check_zoraxy_auth() {
    [ ! -f "$COOKIE_FILE" ] && return 1
    CHECK=$(curl -s -m 2 -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/api/auth/username")
    [[ "$CHECK" == *\"* ]] && [[ "$CHECK" != *"error"* ]] && return 0
    return 1
}

ensure_zoraxy_auth() {
    if check_zoraxy_auth; then return 0; fi
    echo -e "\n${CYAN}üîê Authentification Zoraxy requise ($ZORAXY_API_URL)${NC}"
    HOMEPAGE=$(curl -s -L -k -c "$COOKIE_FILE" -b "$COOKIE_FILE" "$ZORAXY_API_URL/" --max-time 2)
    if [ $? -ne 0 ]; then echo -e "${RED}Zoraxy injoignable sur $ZORAXY_API_URL${NC}"; return 1; fi
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    while true; do
        read -p "Utilisateur Zoraxy : " u
        read -s -p "Mot de passe : " p
        echo ""
        curl -s -k -X POST -c "$COOKIE_FILE" -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" -d "username=$u" -d "password=$p" "$ZORAXY_API_URL/api/auth/login" > /dev/null
        if check_zoraxy_auth; then echo -e "${GREEN}Connect√© √† Zoraxy.${NC}"; return 0;
        else echo -e "${RED}Identifiants incorrects.${NC}"; return 1; fi
    done
}

get_zoraxy_acls() {
    if ! ensure_zoraxy_auth; then return 1; fi
    curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/api/access/list" | jq -r '.[] | "\(.ID)|\(.Name)"' 2>/dev/null
}

add_zoraxy_host() {
    local domain="$1"; local target="$2"; local acl="$3"
    if ! ensure_zoraxy_auth; then return 1; fi
    HOMEPAGE=$(curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/")
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    echo " > Zoraxy: Ajout Proxy $domain -> $target"
    RESPONSE=$(curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" "$ZORAXY_API_URL/api/proxy/add" --data-urlencode "type=host" --data-urlencode "rootname=$domain" --data-urlencode "ep=$target" --data-urlencode "tls=false")
    
    # Check error
    if echo "$RESPONSE" | grep -q "error"; then
        echo -e "${RED}‚ùå Erreur Zoraxy Add:${NC} $RESPONSE"
        return 1
    fi

    if [ -n "$acl" ]; then
        echo " > Zoraxy: Application ACL..."
        CSRF_TOKEN=$(curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
        curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" "$ZORAXY_API_URL/api/access/attach" --data-urlencode "id=$acl" --data-urlencode "host=$domain" > /dev/null
    fi
    echo -e "${GREEN}‚úÖ Zoraxy configur√©.${NC}"
    return 0
}

request_zoraxy_ssl() {
    local domain="$1"
    if ! ensure_zoraxy_auth; then return 1; fi
    echo -e " > Zoraxy: üîë Demande SSL (Let's Encrypt)..."
    HOMEPAGE=$(curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/")
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    RESPONSE=$(curl -s -k -X POST -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" "$ZORAXY_API_URL/api/acme/obtain" --data-urlencode "domain=$domain" --data-urlencode "ca=letsencrypt") 
    if echo "$RESPONSE" | grep -q "error"; then echo -e "${RED}‚ùå ERREUR ZORAXY API :${NC}"; echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"; else echo -e "${GREEN}‚úÖ Demande envoy√©e.${NC}"; fi
}

delete_zoraxy_host() {
    local domain="$1"
    if ! ensure_zoraxy_auth; then return 1; fi
    echo " > Zoraxy: Suppression Proxy $domain"
    HOMEPAGE=$(curl -s -k -b "$COOKIE_FILE" "$ZORAXY_API_URL/")
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" "$ZORAXY_API_URL/api/proxy/del" --data-urlencode "type=host" --data-urlencode "ep=$domain" > /dev/null
    echo -e "${GREEN}‚úÖ Zoraxy nettoy√©.${NC}"
}

# =======================================================
#  3. MODULE API INFOMANIAK
# =======================================================

create_infomaniak_record() {
    local source_sub="$1"; local target="$2"; local record_type="CNAME"
    if [[ "$target" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then record_type="A"; echo " > Infomaniak: D√©tection IP -> Mode 'A'"; else echo " > Infomaniak: D√©tection Domaine -> Mode 'CNAME'"; fi
    echo " > Infomaniak: Cr√©ation $record_type $source_sub -> $target..."
    JSON_DATA=$(jq -n --arg type "$record_type" --arg source "$source_sub" --arg target "$target" --arg ttl "3600" '{type: $type, source: $source, target: $target, ttl: $ttl|tonumber}')
    RESPONSE=$(curl -s -X POST "https://api.infomaniak.com/1/domain/$INFOMANIAK_DOMAIN_ID/dns/record" -H "Authorization: Bearer $INFOMANIAK_TOKEN" -H "Content-Type: application/json" -d "$JSON_DATA")
    STATUS=$(echo "$RESPONSE" | jq -r '.result')
    if [ "$STATUS" == "success" ]; then echo -e "${GREEN}‚úÖ DNS cr√©√©.${NC}"; return 0; else echo -e "${RED}‚ùå Erreur Infomaniak:${NC}"; echo "$RESPONSE" | jq -r '.error.description // .'; return 1; fi
}

delete_infomaniak_record() {
    local source_sub="$1"; echo " > Infomaniak: Recherche ID pour $source_sub..."
    RECORD_ID=$(curl -s -X GET "https://api.infomaniak.com/1/domain/$INFOMANIAK_DOMAIN_ID/dns/record" -H "Authorization: Bearer $INFOMANIAK_TOKEN" | jq -r --arg src "$source_sub" '.data[] | select(.source==$src) | .id' | head -n 1)
    if [ -n "$RECORD_ID" ] && [ "$RECORD_ID" != "null" ]; then
        echo " > Infomaniak: Suppression ID $RECORD_ID..."
        curl -s -X DELETE "https://api.infomaniak.com/1/domain/$INFOMANIAK_DOMAIN_ID/dns/record/$RECORD_ID" -H "Authorization: Bearer $INFOMANIAK_TOKEN" > /dev/null
        echo -e "${GREEN}‚úÖ DNS supprim√©.${NC}"
    else echo -e "${YELLOW}‚ö†Ô∏è  Aucun enregistrement DNS trouv√©.${NC}"; fi
}

# =======================================================
#  4. GESTION DEPLOIEMENT & CONTENU
# =======================================================

handle_github_setup() {
    local target_dir="$1"
    local github_url="$2"
    local web_root_suffix=""

    echo -e "\n${BLUE}--- D√âPLOIEMENT GITHUB ---${NC}"
    
    if [ -d "$target_dir" ] && [ "$(ls -A "$target_dir")" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Le dossier cible n'est pas vide. Suppression...${NC}"
        run_sudo rm -rf "$target_dir"/*
        run_sudo rm -rf "$target_dir"/.* 2>/dev/null
    fi
    
    echo "Clonage de $github_url..."
    if ! run_sudo git clone "$github_url" "$target_dir"; then
        echo -e "${RED}‚ùå √âchec du clonage Git.${NC}"; return 1;
    fi

    run_sudo chown -R $USER:www-data "$target_dir"
    
    # 1. COMPOSER (PHP)
    if [ -f "$target_dir/composer.json" ]; then
        echo -e "\n${CYAN}üêò Fichier composer.json d√©tect√©.${NC}"
        if command -v composer &> /dev/null; then
            echo "Installation des d√©pendances PHP..."
            cd "$target_dir" && composer install --no-dev --optimize-autoloader
        else echo -e "${RED}‚ö†Ô∏è  Composer n'est pas install√© sur ce serveur.${NC}"; fi
    fi

    # 2. NPM (NODE/JS)
    if [ -f "$target_dir/package.json" ]; then
        echo -e "\n${CYAN}üì¶ Fichier package.json d√©tect√©.${NC}"
        if command -v npm &> /dev/null; then
            echo "Installation des d√©pendances Node..."
            cd "$target_dir" && npm install
            echo "Build des assets (npm run build)..."
            cd "$target_dir" && npm run build 2>/dev/null || echo "Pas de script build trouv√©."
        else echo -e "${RED}‚ö†Ô∏è  NPM n'est pas install√© sur ce serveur.${NC}"; fi
    fi

    # 3. D√âTECTION DU DOSSIER PUBLIC
    echo -e "\n${YELLOW}üìÇ Configuration de la racine web (Web Root)${NC}"
    echo "Le serveur Nginx doit pointer vers le dossier public."
    declare -a candidates; candidates+=("/")
    for d in public web dist html build; do
        [ -d "$target_dir/$d" ] && candidates+=("/$d")
    done

    echo -e "Dossiers trouv√©s :"
    for i in "${!candidates[@]}"; do echo "  [$i] .${candidates[$i]}"; done
    
    read -p "Choisissez le dossier racine (d√©faut: 0 [Racine]) : " root_sel
    if [[ "$root_sel" =~ ^[0-9]+$ ]] && [ "$root_sel" -le "${#candidates[@]}" ]; then
        web_root_suffix="${candidates[$root_sel]}"
        [ "$web_root_suffix" == "/" ] && web_root_suffix=""
    else web_root_suffix=""; fi

    echo -e "${GREEN}‚úÖ Racine Web configur√©e : $target_dir$web_root_suffix${NC}"
    run_sudo chown -R www-data:www-data "$target_dir"
    echo "$web_root_suffix" > /tmp/nginx_webroot_suffix
    return 0
}

# --- FONCTION DE ROLLBACK (S√âCURIT√â) ---
perform_rollback() {
    echo -e "\n${RED}${BOLD}üö® ERREUR D√âTECT√âE - D√âBUT DU ROLLBACK AUTOMATIQUE${NC}"
    
    # 1. Supprimer Zoraxy
    if [ "$RB_ZORAXY" -eq 1 ]; then
        echo " üîô Suppression Zoraxy..."
        delete_zoraxy_host "$VAL_FQDN"
    fi

    # 2. Supprimer DNS
    if [ "$RB_DNS" -eq 1 ]; then
        echo " üîô Suppression DNS..."
        delete_infomaniak_record "$VAL_SUB"
    fi

    # 3. Supprimer Firewall
    if [ "$RB_UFW" -eq 1 ]; then
        echo " üîô Fermeture Port $RB_PORT..."
        run_sudo ufw delete allow "$RB_PORT/tcp" >/dev/null
    fi

    # 4. Supprimer Nginx
    if [ "$RB_NGINX" -eq 1 ]; then
        echo " üîô Suppression Config Nginx..."
        run_sudo rm "$SITES_AVAIL/$VAL_FQDN.conf" 2>/dev/null
        run_sudo rm "$SITES_ENAB/$VAL_FQDN.conf" 2>/dev/null
        run_sudo systemctl reload nginx
    fi

    # 5. Supprimer Dossier
    if [ "$RB_FOLDER" -eq 1 ]; then
        echo " üîô Suppression Dossier Web..."
        run_sudo rm -rf "$DIR_WEB/$VAL_FQDN"
    fi

    echo -e "${RED}‚ùå Op√©ration annul√©e et nettoyage effectu√©.${NC}"
    pause
}

# --- NOYAU DE DEPLOIEMENT ---
core_deployment_wizard() {
    local mode="$1"; local source_type="$2"; local github_url="$3"
    
    # VARIABLES ROLLBACK
    RB_FOLDER=0; RB_NGINX=0; RB_UFW=0; RB_DNS=0; RB_ZORAXY=0; RB_PORT=""

    echo -e "\n${BLUE}=== CONFIGURATION DU SITE ($mode) ===${NC}"
    read -p "Sous-domaine (ex: 'app') : " raw_input; [ -z "$raw_input" ] && return
    normalize_domain_input "$raw_input"
    echo -e "   -> Domaine complet : ${CYAN}$VAL_FQDN${NC}"
    
    read -p "Port Nginx Local (ex: 8081) : " port; [ -z "$port" ] && return
    RB_PORT="$port"
    
    local default_target="$INFOMANIAK_DOMAIN_ID"
    [ "$mode" == "lan" ] && default_target="$LOCAL_IP"
    echo -e "Cible DNS (Entr√©e = ${GREEN}$default_target${NC}) :"
    read -p " > " dns_target
    [ -z "$dns_target" ] && dns_target="$default_target"
    if [[ ! "$dns_target" =~ ^[0-9]+ ]]; then [[ "$dns_target" != *.* ]] && dns_target="${dns_target}.${INFOMANIAK_DOMAIN_ID}"; fi
    [[ "$dns_target" == "$VAL_FQDN" ]] && dns_target="$default_target"

    # ACL
    SELECTED_ACL_ID=""; SELECTED_ACL_NAME="Aucune (Public)"
    if [ "$mode" == "lan" ]; then
        echo -e "\n${YELLOW}üîç Configuration ACL (R√©seau Local)${NC}"
        RAW_ACLS=$(get_zoraxy_acls)
        AUTO_ACL_ID=$(echo "$RAW_ACLS" | grep -iE "LAN|Local|Private" | head -n 1 | cut -d'|' -f1)
        AUTO_ACL_NAME=$(echo "$RAW_ACLS" | grep -iE "LAN|Local|Private" | head -n 1 | cut -d'|' -f2)
        if [ -n "$AUTO_ACL_ID" ]; then SELECTED_ACL_ID="$AUTO_ACL_ID"; SELECTED_ACL_NAME="$AUTO_ACL_NAME"; echo -e "‚úÖ ACL Automatique : ${GREEN}$SELECTED_ACL_NAME${NC}"; else
            declare -a ACL_IDS; declare -a ACL_NAMES; local i=1
            while IFS='|' read -r id name; do
                display_name="${name:-$id}"; echo "  $i. $display_name"; ACL_IDS+=("$id"); ACL_NAMES+=("$display_name"); ((i++))
            done <<< "$RAW_ACLS"
            read -p "Num√©ro ACL : " acl_idx
            if [[ "$acl_idx" =~ ^[0-9]+$ ]]; then SELECTED_ACL_ID="${ACL_IDS[$((acl_idx-1))]}"; SELECTED_ACL_NAME="${ACL_NAMES[$((acl_idx-1))]}"; fi
        fi
    fi

    echo -e "\n${YELLOW}üîë SSL / HTTPS${NC}"
    echo "G√©n√©rer un certificat SSL (Let's Encrypt) ?"
    read -p " (o/n) > " ssl_choice

    read -p "Confirmer le d√©ploiement ? (o/n) : " c; if [ "$c" != "o" ]; then return; fi

    # --- INSTALLATION AVEC ROLLBACK ---
    
    echo -e "\n${BOLD}[1/6] Installation du contenu...${NC}"
    if ! ask_sudo_gui; then return; fi
    
    docroot="$DIR_WEB/$VAL_FQDN"
    if [ ! -d "$docroot" ]; then run_sudo mkdir -p "$docroot"; RB_FOLDER=1; fi
    
    WEB_ROOT_SUFFIX=""
    if [ "$source_type" == "github" ]; then
        handle_github_setup "$docroot" "$github_url"
        if [ $? -ne 0 ]; then perform_rollback; return; fi
        WEB_ROOT_SUFFIX=$(cat /tmp/nginx_webroot_suffix 2>/dev/null)
        rm /tmp/nginx_webroot_suffix 2>/dev/null
    else
        echo "<h1>Site $VAL_FQDN</h1><p>Mode: $mode</p>" | run_sudo tee "$docroot/index.html" >/dev/null
        run_sudo chown -R www-data:www-data "$docroot"
    fi

    echo -e "\n${BOLD}[2/6] Configuration Nginx...${NC}"
    conf="$SITES_AVAIL/$VAL_FQDN.conf"
    cat <<EOF | run_sudo tee "$conf" > /dev/null
server {
    listen $port;
    server_name $VAL_FQDN _;
    root $docroot$WEB_ROOT_SUFFIX;
    index index.html index.php;
    absolute_redirect off;
    access_log /var/log/nginx/${VAL_SUB}_access.log;
    error_log /var/log/nginx/${VAL_SUB}_error.log;
    location / { try_files \$uri \$uri/ =404; }
}
EOF
    RB_NGINX=1
    run_sudo ln -sf "$conf" "$SITES_ENAB/$VAL_FQDN.conf"
    if ! run_sudo systemctl reload nginx; then echo "Erreur Reload Nginx"; perform_rollback; return; fi

    echo -e "${BOLD}[3/6] Firewall...${NC}"; 
    run_sudo ufw allow "$port/tcp" >/dev/null
    RB_UFW=1

    echo -e "${BOLD}[4/6] DNS Infomaniak...${NC}"; 
    create_infomaniak_record "$VAL_SUB" "$dns_target"
    if [ $? -ne 0 ]; then perform_rollback; return; fi
    RB_DNS=1

    echo -e "${BOLD}[5/6] Zoraxy Proxy...${NC}"; 
    add_zoraxy_host "$VAL_FQDN" "$LOCAL_IP:$port" "$SELECTED_ACL_ID"
    if [ $? -ne 0 ]; then perform_rollback; return; fi
    RB_ZORAXY=1
    
    if [[ "$ssl_choice" == "o" || "$ssl_choice" == "O" || "$ssl_choice" == "y" ]]; then
        echo -e "${BOLD}[6/6] SSL...${NC}"; request_zoraxy_ssl "$VAL_FQDN"
    else echo -e "${BOLD}[6/6] SSL ignor√©.${NC}"; fi

    echo -e "\n${GREEN}üéâ Termin√© !${NC}"
    read -p "Voulez-vous √©diter le fichier Nginx maintenant ? (o/n) " ed
    if [ "$ed" == "o" ]; then run_sudo nano "$conf"; run_sudo systemctl reload nginx; fi
    pause
}

# --- MENU CR√âATION (ETAPE 1 : SOURCE) ---
wizard_new_site_menu() {
    clear
    echo -e "${BLUE}################################################${NC}"
    echo -e "${BLUE}#           CR√âATION D'UN NOUVEAU SITE         #${NC}"
    echo -e "${BLUE}################################################${NC}"
    echo ""
    echo -e "${BOLD}√âTAPE 1 : SOURCE DU SITE${NC}"
    echo -e "${GREEN}1. üìÑ Site Vierge${NC}        ${GREY}(Commencez de z√©ro avec une page simple)${NC}"
    echo -e "${YELLOW}2. üêô Import GitHub${NC}      ${GREY}(Clone projet + D√©pendances)${NC}"
    echo -e "${RED}0. Retour${NC}"
    echo ""
    read -p "Choix > " src_choice
    
    source_type="vierge"
    github_url=""
    
    case "$src_choice" in
        1) source_type="vierge" ;;
        2) 
            source_type="github"
            read -p "URL du d√©p√¥t GitHub : " github_url
            [ -z "$github_url" ] && return
            ;;
        0) return ;;
        *) echo "Invalide"; pause; return ;;
    esac

    echo -e "\n${BOLD}√âTAPE 2 : ACCESSIBILIT√â${NC}"
    echo -e "${GREEN}1. üåç SITE PUBLIC${NC}        ${GREY}(Ex: Blog, Portfolio - Accessible Internet)${NC}"
    echo -e "${YELLOW}2. üè† SITE PRIV√â${NC}         ${GREY}(Ex: NAS, Admin - Accessible R√©seau de la pharmacie)${NC}"
    echo ""
    read -p "Choix > " access_type
    
    case "$access_type" in
        1) core_deployment_wizard "public" "$source_type" "$github_url" ;;
        2) 
            echo -e "\n${YELLOW}--- Options Site Priv√© ---${NC}"
            echo "1. Avec Nom de Domaine (Recommand√©)"
            echo "2. Par IP Directe (Simple)"
            read -p "> " sub
            [ "$sub" == "1" ] && core_deployment_wizard "lan" "$source_type" "$github_url"
            [ "$sub" == "2" ] && echo "Mode IP simple non compatible avec GitHub auto." && pause
            ;;
    esac
}

create_simple_vhost_wizard() {
    echo -e "\n${GREEN}‚ûï SITE SIMPLE (IP:PORT)${NC}"
    echo "Ce site sera accessible via http://$LOCAL_IP:PORT"
    read -p "Nom du projet (nom dossier) : " d; [ -z "$d" ] && return
    read -p "Port √† ouvrir : " port; [ -z "$port" ] && return
    if ! ask_sudo_gui; then return; fi
    
    setup_site_content "$DIR_WEB/$d" "Local"

    conf="$SITES_AVAIL/$d.conf"
    cat <<EOF | run_sudo tee "$conf" > /dev/null
server {
    listen $port;
    server_name _;
    root $DIR_WEB/$d;
    index index.html;
    absolute_redirect off;
}
EOF
    run_sudo ln -sf "$conf" "$SITES_ENAB/$d.conf"
    run_sudo ufw allow "$port/tcp" >/dev/null
    run_sudo systemctl reload nginx
    echo -e "\n${GREEN}‚úÖ Site actif sur : http://$LOCAL_IP:$port${NC}"; pause
}

# --- ACTIONS SUPPLEMENTAIRES ---

action_toggle_vhost() {
    refresh_vhost_list; read -p "Site # (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"; bn=$(basename "$f")
    if ask_sudo_gui; then
        if ls "$SITES_ENAB/$bn"* 1>/dev/null 2>&1; then run_sudo rm "$SITES_ENAB/$bn"*; else run_sudo ln -sf "$f" "$SITES_ENAB/$bn"; fi
        run_sudo systemctl reload nginx; pause
    fi
}

action_edit_vhost() {
    refresh_vhost_list; read -p "Site # (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"
    if ask_sudo_gui; then
        run_sudo cp "$f" "$f.bak_tmp"; run_sudo nano "$f"
        if run_sudo nginx -t; then run_sudo rm "$f.bak_tmp"; run_sudo systemctl reload nginx; else echo "${RED}Erreur Syntaxe!${NC}"; run_sudo mv "$f.bak_tmp" "$f"; fi
        pause
    fi
}

action_ssl_retry() {
    refresh_vhost_list; read -p "Site # (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"; filename=$(basename "$f"); domain_conf="${filename%.*}"
    request_zoraxy_ssl "$domain_conf"; pause
}

action_delete_wizard() {
    refresh_vhost_list; read -p "Site # √† SUPPRIMER (0=Retour) : " sel; [ "$sel" == "0" ] && return
    f="${VHOST_FILES[$((sel-1))]}"; filename=$(basename "$f"); domain_conf="${filename%.*}"
    content=$(sudo cat "$f" 2>/dev/null); target_port=$(echo "$content" | grep -E "^\s*listen" | grep -oE "[0-9]+" | head -n1)
    normalize_domain_input "$domain_conf"
    
    echo -e "${RED}SUPPRESSION : $filename (Port $target_port)${NC}"
    read -p "Confirmer ? (oui) : " c; if [ "$c" != "oui" ]; then return; fi
    if ! ask_sudo_gui; then return; fi

    if [[ "$domain_conf" == *"$INFOMANIAK_DOMAIN_ID" ]]; then
        delete_infomaniak_record "$VAL_SUB"; delete_zoraxy_host "$VAL_FQDN"
    fi
    [ -n "$target_port" ] && run_sudo ufw delete allow "$target_port/tcp" >/dev/null
    run_sudo rm "$f"; target_link=$(find "$SITES_ENAB" -name "$filename*"); [ -n "$target_link" ] && run_sudo rm "$target_link"
    run_sudo systemctl reload nginx
    read -p "Supprimer dossier web ? (o/n) " dw; [ "$dw" == "o" ] && run_sudo rm -rf "$DIR_WEB/$domain_conf"
    echo "Termin√©."; pause
}

# =======================================================
#  6. MENU PRINCIPAL DE GESTION DES SITES
# =======================================================

declare -a VHOST_FILES
refresh_vhost_list() {
    VHOST_FILES=()
    shopt -s nullglob
    local files=("$SITES_AVAIL"/*)
    shopt -u nullglob
    echo -e "${BLUE}=== LISTE DES SITES ACTUELS ===${NC}"
    printf "${GREY}%-3s %-30s %-8s %-10s${NC}\n" "ID" "DOMAINE / NOM" "PORT" "√âTAT"
    echo "--------------------------------------------------------"
    if [ ${#files[@]} -eq 0 ]; then echo "   (Aucun site configur√©)"; else
        local i=1
        for f in "${files[@]}"; do
            VHOST_FILES+=("$f")
            bn=$(basename "$f"); bn_noext="${bn%.*}"
            st=$(ls "$SITES_ENAB/$bn"* 1> /dev/null 2>&1 && echo "${GREEN}ON${NC}" || echo "${RED}OFF${NC}")
            content=$(sudo cat "$f" 2>/dev/null)
            port=$(echo "$content" | grep -E "^\s*listen" | grep -oE "[0-9]+" | head -n1)
            [ -z "$port" ] && port="-"
            printf "%-3s %-30s %-8s %b\n" "$i" "${bn_noext:0:28}" "$port" "$st"
            ((i++))
        done
    fi
    echo "--------------------------------------------------------"
}

manage_nginx_sites_menu() {
    while true; do
        clear
        echo -e "${BLUE}################################################${NC}"
        echo -e "${BLUE}#           GESTION DES SITES WEB              #${NC}"
        echo -e "${BLUE}################################################${NC}"
        echo -e "${CYAN}Administration centralis√©e Nginx + Zoraxy + DNS${NC}"
        echo ""
        
        echo -e "  ${GREEN}1.${NC} ‚ú® Cr√©er un Site         ${GREY}: Assistant (Vierge / GitHub)${NC}"
        echo -e "  ${YELLOW}2.${NC} ‚èØÔ∏è  Activer / D√©sactiver ${GREY}: ON/OFF sans supprimer${NC}"
        echo -e "  ${CYAN}3.${NC} üìù √âditer Config         ${GREY}: Modifier VHost${NC}"
        echo -e "  ${RED}4.${NC} üóëÔ∏è  Supprimer un Site    ${GREY}: Nettoyage complet${NC}"
        echo -e "  ${BLUE}7.${NC} üîë R√©parer SSL           ${GREY}: Forcer certificat${NC}"
        echo -e "  ${RED}0.${NC} üîô Retour"
        read -r -p "Choix > " ch
        case "$ch" in
            1) wizard_new_site_menu ;;
            2) action_toggle_vhost ;;
            3) action_edit_vhost ;;
            4) action_delete_wizard ;;
            7) action_ssl_retry ;;
            0) break ;;
        esac
    done
}

# =======================================================
#  7. MENU SYSTEME & LOOP
# =======================================================

firewall_manager() {
    while true; do
        clear; echo -e "${BLUE}=== GESTION PARE-FEU ===${NC}"
        run_sudo ufw status numbered
        echo -e "1. Ouvrir Port | 2. Supprimer R√®gle | 0. Retour"
        read -r -p "> " c
        case "$c" in
            1) read -p "Port: " p; [ -n "$p" ] && ask_sudo_gui && run_sudo ufw allow "$p"; pause ;;
            2) read -p "Num√©ro: " n; [ -n "$n" ] && ask_sudo_gui && echo "y" | run_sudo ufw delete "$n"; pause ;;
            0) return ;;
        esac
    done
}

deploy_from_github() { echo "Obsol√®te. Utilisez 'Cr√©er un Site'."; pause; }
backup_menu() {
    while true; do
        clear; echo -e "${BLUE}=== BACKUP ===${NC}"
        ls -lh "$BACKUP_DIR" 2>/dev/null | grep "tar.gz"
        echo "1. Backup Full Nginx | 0. Retour"
        read -r -p "> " c
        if [ "$c" == "1" ] && ask_sudo_gui; then
            run_sudo mkdir -p "$BACKUP_DIR"
            run_sudo tar -czf "$BACKUP_DIR/NGINX_FULL_$(date +%Y%m%d).tar.gz" "$NGINX_HOME" "$DIR_WEB"
            echo "Backup cr√©√©."; pause
        elif [ "$c" == "0" ]; then return; fi
    done
}

while true; do
    clear; ensure_requirements; get_sys_info
    
    echo -e "${BLUE}################################################${NC}"
    echo -e "${BLUE}#           MANAGER SERVEUR WEB                #${NC}"
    echo -e "${BLUE}################################################${NC}"

    printf "  üñ•Ô∏è  %-21s | ‚è±Ô∏è  (System)\n" "${CYAN}$OS_NAME${NC}"
    printf "  üè† LAN: %-15s | üåç WAN: %s\n" "${YELLOW}$LOCAL_IP${NC}" "${YELLOW}$PUBLIC_IP${NC}"
    echo -e "$SEP"
    printf "  üîå Service : %-12b | üõ°Ô∏è  Pare-feu : %s\n" "$SX" "$FW"
    printf "  ‚ÑπÔ∏è  Version : %-12s | ‚öì Ports    : %s/%s\n" "${CYAN}$APP_VER${NC}" "${YELLOW}80${NC}" "${YELLOW}443${NC}"
    echo -e "$SEP"

    echo -e " ${BOLD}${CYAN}‚ö° GESTION DU SERVICE${NC}"
    echo -e "    ${GREEN}1.${NC} ‚ñ∂Ô∏è  D√©marrer le service"
    echo -e "    ${GREEN}2.${NC} ‚èπÔ∏è  Arr√™ter le service"
    echo -e "    ${GREEN}3.${NC} üîÑ Red√©marrer le service"
    echo -e "    ${GREEN}4.${NC} üìú Logs du service"
    echo ""
    echo -e " ${BOLD}${CYAN}üåê SITES & D√âPLOIEMENT${NC}"
    echo -e "    ${GREEN}5.${NC} üåê Gestion des Sites Web (Ajout/Suppr)"
    echo -e "    ${GREEN}6.${NC} üêô D√©ployer via GitHub (Obsol√®te -> Voir 5)"
    echo ""
    echo -e " ${BOLD}${CYAN}üõ°Ô∏è  S√âCURIT√â & MAINTENANCE${NC}"
    echo -e "    ${GREEN}7.${NC} üß± Pare-feu (UFW)"
    echo -e "    ${GREEN}8.${NC} üîí Shell Restreint (Jail)"
    echo -e "    ${GREEN}9.${NC} üíæ Sauvegardes"
    echo -e "    ${GREEN}10.${NC}üöÄ Mises √† jour Syst√®me"
    echo -e "$SEP_RED"
    echo -e " ${BOLD}${RED}üíÄ ZONES SYST√àME${NC}"
    echo -e "    ${RED}11.${NC}üîå √âteindre le serveur"
    echo -e "    ${RED}12.${NC}‚ôªÔ∏è  Red√©marrer le serveur"
    echo -e "$SEP"
    echo -e "  [${RED}exit${NC}] üö™ Quitter"
    echo -e "$SEP"

    read -r -p "  Votre choix > " ch

    case "$ch" in
        1) ask_sudo_gui && run_sudo systemctl start nginx; pause ;;
        2) ask_sudo_gui && run_sudo systemctl stop nginx; pause ;;
        3) ask_sudo_gui && run_sudo systemctl restart nginx; pause ;;
        4) run_sudo tail -f "$LOG_ERROR" ;;
        5) manage_nginx_sites_menu ;;
        7) firewall_manager ;;
        9) backup_menu ;;
        10) ask_sudo_gui && sudo apt update && sudo apt upgrade -y; pause ;;
        11) ask_sudo_gui && sudo poweroff ;;
        12) ask_sudo_gui && sudo reboot ;;
        exit|q) exit 0 ;;
        *) echo "Choix invalide"; sleep 1 ;;
    esac
done
