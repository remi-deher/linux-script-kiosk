#!/bin/bash

# ==============================================================================
# A AJOUTER DANS LOCAL.D POUR LE DEMARRER EN MODE KIOSK
# ==============================================================================

# Auto-start Zoraxy Manager Kiosk
# Ne se lance que si :
# 1. Le shell est interactif
# 2. La variable SKIP n'est pas d√©finie
# 3. La commande existe
# 4. L'utilisateur n'est pas root (optionnel, pour s√©curit√©)
#
#if [[ $- == *i* ]] && [ -z "$SKIP_ZORAXY_MENU" ] && [ "$EUID" -ne 0 ]; then
#    if command -v zoraxy-manager &> /dev/null; then
#        zoraxy-manager
#    fi
#fi
# ==============================================================================
# Configurer Sudo (Optionnel pour UFW)
# ==============================================================================

#sudo visudo -f /etc/sudoers.d/zoraxy-ufw
# Ajouter : %gmon_groupe ALL=(ALL) NOPASSWD: /usr/sbin/ufw status*

# =======================================================
# ZORAXY MANAGER
# =======================================================

# --- CONFIGURATION ---
ZORAXY_HOME="/etc/zoraxy"
SERVICE_NAME="zoraxy"
BACKUP_DIR="/var/backups/zoraxy"
VERSION_FILE="$ZORAXY_HOME/current_version"
GITHUB_REPO="tobychui/zoraxy"
COOKIE_FILE="/tmp/zoraxy_cookie.txt"
VERSION_CACHE="/tmp/zoraxy_latest_ver"
PUBLIC_IP_CACHE="/tmp/zoraxy_public_ip" 

# Dossiers de configuration
CONF_PROXY="$ZORAXY_HOME/conf/proxy"
CONF_CERT="$ZORAXY_HOME/conf/certs"

# --- S√âCURIT√â KIOSK ---
trap '' SIGINT SIGQUIT SIGTSTP

# --- COULEURS ---
BLUE=$'\033[0;34m'
GREEN=$'\033[0;32m'
RED=$'\033[0;31m'
YELLOW=$'\033[1;33m'
CYAN=$'\033[0;36m'
GREY=$'\033[1;30m'
NC=$'\033[0m'
BOLD=$'\033[1m'

# --- 1. FONCTIONS SYST√àME DE BASE ---

ask_sudo_gui() {
    if sudo -n true 2>/dev/null; then return 0; fi
    echo -e "\n${YELLOW}üîí Authentification requise (Mot de passe Sudo)${NC}"
    read -s -p "Mot de passe : " user_pass; echo ""
    echo "$user_pass" | sudo -S -v 2>/dev/null
    if [ $? -eq 0 ]; then return 0; else echo -e "${RED}‚ùå Mot de passe incorrect.${NC}"; pause; return 1; fi
}

run_sudo() {
    if [[ "$*" == *"ufw status"* ]] && sudo -n /usr/sbin/ufw status >/dev/null 2>&1; then sudo "$@"; return $?; fi
    if ! ask_sudo_gui; then return 1; fi
    sudo "$@"
}

pause() { echo ""; read -p "Appuyez sur Entr√©e pour continuer..."; }

check_requirements() {
    for cmd in jq curl grep sed awk tar wget openssl nano; do
        if ! command -v $cmd &> /dev/null; then echo -e "${RED}‚ùå Erreur : '$cmd' requis.${NC}"; exit 1; fi
    done
}

detect_api_url() {
    SERVICE_FILE=$(systemctl show -p FragmentPath "$SERVICE_NAME" 2>/dev/null | cut -d= -f2)
    if [ -f "$SERVICE_FILE" ]; then
        PORT_ARG=$(grep "ExecStart=" "$SERVICE_FILE" | grep -o "\-port=:[0-9]*" | cut -d: -f2)
        CURRENT_PORT="${PORT_ARG:-8000}"
    else CURRENT_PORT="8000"; fi
    API_URL="http://127.0.0.1:$CURRENT_PORT"
}

get_sys_info() {
    detect_api_url
    LOCAL_IP=$(hostname -I | awk '{print $1}')
    RAM_USG=$(free -h | awk '/^Mem:/ {print $3 "/" $2}')
    CPU_LOAD=$(top -bn1 | grep "Cpu(s)" | awk '{print $2 + $4 "%"}')
    [ -z "$CPU_LOAD" ] && CPU_LOAD="N/A"
    PUBLIC_IP=$(get_remote_ip_managed) 
}

get_local_version() { 
    if [ -f "$VERSION_FILE" ]; then cat "$VERSION_FILE"; else echo "Inconnue"; fi; 
}

get_remote_version_managed() {
    if [ -f "$VERSION_CACHE" ]; then
        LAST_MOD=$(stat -c %Y "$VERSION_CACHE")
        NOW=$(date +%s); DIFF=$((NOW - LAST_MOD))
        if [ $DIFF -lt 3600 ]; then cat "$VERSION_CACHE"; return; fi
    fi
    local UA="Mozilla/5.0 (compatible; ZoraxyManager/1.0)"
    local TARGET_URL=$(curl -s -L -I -A "$UA" -m 3 -o /dev/null -w '%{url_effective}' "https://github.com/$GITHUB_REPO/releases/latest")
    local VER=$(basename "$TARGET_URL")
    if [ "$VER" == "latest" ] || [ -z "$VER" ] || [[ "$VER" != v* ]]; then
        VER=$(curl -s -A "$UA" -m 3 "https://api.github.com/repos/$GITHUB_REPO/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    fi
    if [[ "$VER" == v* ]]; then echo "$VER" > "$VERSION_CACHE"; echo "$VER"; else [ -f "$VERSION_CACHE" ] && cat "$VERSION_CACHE"; fi
}

get_remote_ip_managed() { 
    # 1. V√©rification du cache (1 heure de validit√©)
    if [ -f "$PUBLIC_IP_CACHE" ]; then
        LAST_MOD=$(stat -c %Y "$PUBLIC_IP_CACHE")
        NOW=$(date +%s); DIFF=$((NOW - LAST_MOD))
        if [ $DIFF -lt 3600 ]; then cat "$PUBLIC_IP_CACHE"; return; fi
    fi

    # 2. Tentative de r√©cup√©ration (timeout 3s)
    local PUB_IP=$(curl -s -4 -m 3 https://icanhazip.com 2>/dev/null)
    
    # 3. Mise en cache si r√©ussi, sinon retourne la valeur en cache si elle existe
    if [[ "$PUB_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then 
        echo "$PUB_IP" | tee "$PUBLIC_IP_CACHE"
    else 
        [ -f "$PUBLIC_IP_CACHE" ] && cat "$PUBLIC_IP_CACHE" || echo "N/A"
    fi
}

# --- 2. FONCTIONS API ZORAXY ---

api_login() {
    local force_new=$1; [ "$force_new" == "true" ] && rm -f "$COOKIE_FILE"
    HOMEPAGE=$(curl -s -L -k -c "$COOKIE_FILE" -b "$COOKIE_FILE" "$API_URL/")
    CSRF_TOKEN=$(echo "$HOMEPAGE" | grep -o 'name="zoraxy.csrf.Token" content="[^"]*"' | head -n 1 | sed 's/.*content="//;s/"//')
    if [ -z "$CSRF_TOKEN" ]; then echo -e "${RED}‚ùå Erreur: Zoraxy injoignable ($API_URL)${NC}"; return 1; fi
    if [ -f "$COOKIE_FILE" ] && [ "$force_new" != "true" ]; then
        CHECK=$(curl -s -k -b "$COOKIE_FILE" "$API_URL/api/auth/username"); if [[ "$CHECK" == \"*\" ]]; then return 0; fi
    fi
    echo -e "\n${CYAN}üîê Authentification Zoraxy requise...${NC}"
    read -p "Utilisateur : " z_user; [ -z "$z_user" ] && echo "Annul√©." && return 1
    read -s -p "Mot de passe : " z_pass; echo ""; [ -z "$z_pass" ] && echo "Annul√©." && return 1
    HTTP_CODE=$(curl -s -k -L -o /dev/null -w "%{http_code}" -X POST -c "$COOKIE_FILE" -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" -d "username=$z_user" -d "password=$z_pass" "$API_URL/api/auth/login")
    if [ "$HTTP_CODE" == "200" ]; then echo -e "${GREEN}‚úÖ Connect√©.${NC}"; return 0; else echo -e "${RED}‚ùå √âchec ($HTTP_CODE).$NC"; return 1; fi
}

get_json_list() {
    if api_login "true"; then curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" --data-urlencode "type=host" "$API_URL/api/proxy/list"; else echo "ERROR"; return 1; fi
}

# --- 3. FONCTIONS SHELL AVANC√âES ---

spawn_restricted_shell() {
    local T="$1"; local N="$2"; [ ! -d "$T" ] && run_sudo mkdir -p "$T"
    cd "$T" || return
    echo -e "\n${GREEN}üîí JAIL $N${NC}"
    echo -e "Commandes : ${CYAN}ls, cd, cat, nano (read-only), cp, mv, rm, mkdir, pwd, chown, chmod${NC}"
    echo -e "Tapez 'exit' pour sortir."
    
    # On autorise Ctrl+C pour interrompre une commande en cours (ex: cat d'un gros fichier)
    trap 'echo ""' SIGINT
    
    while true; do
        R="${PWD#$T}"; [ -z "$R" ] && R="/"
        # Gestion propre de l'entr√©e vide
        if ! read -e -p "${YELLOW}$N${NC}:[${BLUE}$R${NC}]$ " c a; then break; fi
        
        [ -z "$c" ] && continue
        
        # S√©curit√© anti-√©vasion
        if [[ "$a" == /* || "$a" == *" /"* || ("$c" != "cd" && "$a" == *".."*) ]]; then 
            echo "${RED}‚õî Chemin interdit (restez dans $N)${NC}"; continue
        fi
        
        case "$c" in
            cd) [ -z "$a" ] && cd "$T" || { cd "$a" 2>/dev/null; [[ "$PWD" != "$T"* ]] && cd "$T"; } ;;
            ls|ll|la) ls --color=auto -h $a ;;
            cat) [ -f "$a" ] && cat "$a" ;;
            # Nano intelligent : Lecture seule si pas proprio, sudo sinon
            nano) if [ -w "$a" ] || [ ! -e "$a" ] && [ -w . ]; then nano -R "$a"; else run_sudo nano -R "$a"; fi ;;
            mkdir) run_sudo mkdir -p "$a" ;;
            cp) run_sudo cp -r $a ;;
            mv) run_sudo mv $a ;;
            rm) run_sudo rm -rf $a ;;
            chown) run_sudo chown $a ;;
            chmod) run_sudo chmod $a ;;
            pwd) echo "$PWD" ;;
            clear) clear ;;
            exit|quit) break ;;
            *) echo "${RED}Commande inconnue ou interdite${NC}" ;;
        esac
    done
    # R√©tablissement s√©curit√© Kiosk
    trap '' SIGINT SIGQUIT SIGTSTP
}

open_user_shell() {
    # On utilise ask_sudo_gui pour demander le mot de passe proprement
    # Cela sert d'authentification forte avant de donner le shell
    if ! ask_sudo_gui; then return; fi

    echo -e "\n${GREEN}üîì Acc√®s autoris√©.${NC} Tapez 'exit' pour revenir au menu."
    
    # 1. Lib√©rer les signaux pour que le shell soit utilisable normalement
    trap - SIGINT SIGQUIT SIGTSTP
    
    # 2. IMPORTANT : Variable pour √©viter la boucle infinie dans .bashrc / profile.d
    export SKIP_ZORAXY_MENU="true"
    
    # 3. Lancer le shell de login
    bash --login
    
    # 4. Nettoyage apr√®s la sortie
    unset SKIP_ZORAXY_MENU
    trap '' SIGINT SIGQUIT SIGTSTP
}

# --- 4. GESTION VHOST & SSL ---

show_vhost_table_local() {
    echo -e "${BOLD}üìã SITES WEB (Lecture Locale)${NC}"
    printf "%-30s | %-25s | %-12s | %s\n" "DOMAINE" "CIBLE" "SSL" "EXPIRATION"
    echo "---------------------------------------------------------------------------------"
    if ! sudo -n ls "$CONF_PROXY" >/dev/null 2>&1; then
        if [ ! -d "$CONF_PROXY" ]; then echo -e "${YELLOW}Config introuvable.${NC}"; return; fi
    fi
    shopt -s nullglob; FOUND=0
    for file in "$CONF_PROXY"/*.config; do
        if [ -e "$file" ]; then
            JSON_CONTENT=$(sudo cat "$file")
            DOMAIN=$(echo "$JSON_CONTENT" | jq -r '.RootOrMatchingDomain // empty'); [ -z "$DOMAIN" ] && continue
            TARGET=$(echo "$JSON_CONTENT" | jq -r '.ActiveOrigins[0].OriginIpOrDomain // "N/A"')
            CERT_FILE="$CONF_CERT/$DOMAIN.pem"
            if sudo test -f "$CERT_FILE"; then
                SSL_STATUS="${GREEN}OUI${NC}"
                END_DATE=$(sudo openssl x509 -enddate -noout -in "$CERT_FILE" 2>/dev/null | cut -d= -f2)
                if [ -n "$END_DATE" ]; then EXP_STR=$(date -d "$END_DATE" +'%Y-%m-%d' 2>/dev/null); [ -z "$EXP_STR" ] && EXP_STR="$END_DATE"; else EXP_STR="Inconnue"; fi
            else SSL_STATUS="${RED}NON${NC}"; EXP_STR="-"; fi
            printf "%-30s | %-25s | %-12b | %s\n" "${DOMAIN:0:30}" "${TARGET:0:25}" "$SSL_STATUS" "$EXP_STR"
            ((FOUND++))
        fi
    done
    shopt -u nullglob; if [ "$FOUND" -eq 0 ]; then echo -e "${GREY}   Aucun h√¥te configur√©.${NC}"; fi
    echo "---------------------------------------------------------------------------------"
}

select_domain_from_api() {
    local list_json=$1; local action_name=$2
    mapfile -t DOMAINS < <(echo "$list_json" | jq -r '.[] | .RootOrMatchingDomain')
    if [ ${#DOMAINS[@]} -eq 0 ]; then echo -e "${YELLOW}Aucun domaine.${NC}"; return 1; fi
    echo -e "\n${BOLD}S√©lectionnez le domaine √† $action_name :${NC}"
    for i in "${!DOMAINS[@]}"; do printf "  ${CYAN}%2d.${NC} %s\n" "$((i+1))" "${DOMAINS[$i]}"; done
    echo "   0. Annuler"
    read -p "Num√©ro > " selection
    if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -le "${#DOMAINS[@]}" ]; then echo "${DOMAINS[$((selection-1))]}"; return 0; else return 1; fi
}

api_add_host() {
    echo -e "\n${BOLD}‚ûï AJOUTER SITE${NC}"; if ! api_login; then pause; return; fi
    read -p "Domaine : " d; read -p "Cible (IP:Port) : " t; [ -z "$d" ] && return
    read -p "HTTPS Cible ? (o/n) : " x; [ "$x" == "o" ] && tls="true" || tls="false"
    curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" --data-urlencode "type=host" --data-urlencode "rootname=$d" --data-urlencode "ep=$t" --data-urlencode "tls=$tls" "$API_URL/api/proxy/add" > /dev/null
    echo -e "${GREEN}Ajout√©.${NC}"; pause
}

api_del_host() {
    echo -e "\n${BOLD}üóëÔ∏è  SUPPRIMER SITE${NC}"; if ! api_login; then pause; return; fi
    LIST=$(get_json_list); if [[ "$LIST" == "ERROR" ]]; then pause; return; fi
    DOM=$(select_domain_from_api "$LIST" "supprimer")
    if [ -n "$DOM" ]; then
        read -p "Confirmer suppression de $DOM ? (o/n) " c
        if [ "$c" == "o" ]; then
            curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" --data-urlencode "type=host" --data-urlencode "ep=$DOM" "$API_URL/api/proxy/del" > /dev/null
            echo -e "${GREEN}Supprim√©.${NC}"
        fi
    fi
    pause
}

api_edit_host() {
    echo -e "\n${BOLD}‚úèÔ∏è  MODIFIER CIBLE${NC}"; if ! api_login; then pause; return; fi
    LIST=$(get_json_list); if [[ "$LIST" == "ERROR" ]]; then pause; return; fi
    DOM=$(select_domain_from_api "$LIST" "modifier")
    if [ -n "$DOM" ]; then
        OLD=$(echo "$LIST" | jq -r --arg d "$DOM" '.[] | select(.RootOrMatchingDomain==$d) | .ActiveOrigins[0].OriginIpOrDomain')
        echo -e "Actuel : ${YELLOW}$OLD${NC}"; read -p "Nouvelle Cible : " NEW
        [ -n "$NEW" ] && curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" --data-urlencode "ep=$DOM" --data-urlencode "origin=$OLD" --data-urlencode "payload={\"OriginIpOrDomain\":\"$NEW\"}" --data-urlencode "active=true" "$API_URL/api/proxy/upstream/update" > /dev/null
        echo -e "${GREEN}Modifi√©.${NC}"
    fi
    pause
}

generate_ssl_api() {
    echo -e "\n${CYAN}üîê G√©n√©ration SSL${NC}"; if ! api_login; then pause; return; fi
    read -p "Domaine : " d; read -p "Email : " e; [ -z "$d" ] && return
    echo -e "${YELLOW}En cours...${NC}"
    RES=$(curl -s -X POST -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" --data-urlencode "domains=$d" --data-urlencode "filename=$d" --data-urlencode "email=$e" --data-urlencode "ca=Let's Encrypt" --data-urlencode "skipTLS=false" --data-urlencode "dns=false" "$API_URL/api/acme/obtainCert")
    if [[ "$RES" == "true" ]]; then echo -e "${GREEN}OK.${NC}"; else echo -e "${RED}Erreur.${NC}"; fi; pause
}

renew_ssl_checkbox() {
    if ! api_login; then pause; return; fi
    LIST=$(get_json_list); if [[ "$LIST" == "ERROR" ]]; then pause; return; fi
    mapfile -t D < <(echo "$LIST" | jq -r '.[] | .RootOrMatchingDomain')
    if [ ${#D[@]} -eq 0 ]; then echo "Vide."; pause; return; fi
    declare -a SEL; for i in "${!D[@]}"; do SEL[$i]=false; done
    while true; do
        clear; echo -e "${BOLD}Renouvellement SSL (S√©lection)${NC}"
        for i in "${!D[@]}"; do
            if [ "${SEL[$i]}" == "true" ]; then M="${GREEN}[X]${NC}"; else M="[ ]"; fi
            printf " %b %2d. %s\n" "$M" "$((i+1))" "${D[$i]}"
        done
        echo -e "[a] Tout | [n] Rien | [v] VALIDER | [q] Retour"
        read -r -p "> " k
        if [[ "$k" =~ ^[0-9]+$ ]] && [ "$k" -ge 1 ] && [ "$k" -le "${#D[@]}" ]; then idx=$((k-1)); if [ "${SEL[$idx]}" == "true" ]; then SEL[$idx]=false; else SEL[$idx]=true; fi
        elif [ "$k" == "a" ]; then for i in "${!D[@]}"; do SEL[$i]=true; done
        elif [ "$k" == "n" ]; then for i in "${!D[@]}"; do SEL[$i]=false; done
        elif [ "$k" == "v" ]; then
            read -p "Email ACME : " MAIL; [ -z "$MAIL" ] && continue
            echo -e "${CYAN}Lancement...${NC}"
            for i in "${!D[@]}"; do
                if [ "${SEL[$i]}" == "true" ]; then
                    echo -ne " ${D[$i]}... "
                    curl -s -X POST -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" --data-urlencode "domains=${D[$i]}" --data-urlencode "filename=${D[$i]}" --data-urlencode "email=$MAIL" --data-urlencode "ca=Let's Encrypt" --data-urlencode "skipTLS=false" --data-urlencode "dns=false" "$API_URL/api/acme/obtainCert" >/dev/null && echo "OK" || echo "Err"
                fi
            done
            pause; return
        elif [ "$k" == "q" ]; then return; fi
    done
}

# --- 5. CENTRE DE MISE √Ä JOUR ---

menu_update_center() {
    while true; do
        clear
        echo -e "${BLUE}#############################################${NC}"
        echo -e "${BLUE}#           CENTRE DE MISE √Ä JOUR           #${NC}"
        echo -e "${BLUE}#############################################${NC}"
        
        LOCAL_VER=$(get_local_version)
        echo -e "  üìå Zoraxy Actuel : ${YELLOW}$LOCAL_VER${NC}"
        
        # Appel de la fonction g√©r√©e qui retourne le string
        REMOTE_VER=$(get_remote_version_managed)

        if [ -z "$REMOTE_VER" ]; then
            Z_STATUS="${RED}Hors Ligne${NC}"
            Z_MSG="${GREY}Mise √† jour impossible${NC}"
        elif [ "$LOCAL_VER" == "$REMOTE_VER" ]; then
            Z_STATUS="${GREEN}√Ä jour${NC}"
            Z_MSG="üîÑ Forcer r√©installation Zoraxy"
        else
            Z_STATUS="${YELLOW}Nouveau : $REMOTE_VER${NC}"
            Z_MSG="üöÄ Mettre √† jour Zoraxy ($REMOTE_VER)"
        fi
        
        echo -e "  üåç Zoraxy Dispo  : $Z_STATUS"

        if [ -f "$ZORAXY_HOME/zoraxy.old" ]; then RB_OK="true"; else RB_OK="false"; fi

        echo "---------------------------------------------"
        echo -e "${BOLD}APPLICATION ZORAXY :${NC}"
        echo -e "  ${GREEN}1.${NC} $Z_MSG"
        if [ "$RB_OK" == "true" ]; then
            echo -e "  ${YELLOW}2.${NC} üîô Rollback Zoraxy"
        else
            echo -e "  ${GREY}2. üîô Rollback (Indisponible)${NC}"
        fi
        echo "---------------------------------------------"
        echo -e "${BOLD}SYST√àME D'EXPLOITATION (OS) :${NC}"
        echo -e "  ${CYAN}3.${NC} üîÑ Mise √† jour paquets (apt update/upgrade)"
        echo -e "  ${CYAN}4.${NC} üÜô Mise √† niveau compl√®te (apt dist-upgrade)"
        echo -e "  ${CYAN}5.${NC} üìù √âditer les d√©p√¥ts (sources.list)"
        echo "---------------------------------------------"
        echo -e "  ${RED}0.${NC} üîô Retour"
        echo "---------------------------------------------"
        read -r -p "Choix > " uc

        case "$uc" in
            1) if [ -z "$REMOTE_VER" ]; then pause; continue; fi
               if ! ask_sudo_gui; then continue; fi
               echo -e "\n${YELLOW}T√©l√©chargement...${NC}"
               if wget -q --show-progress -O /tmp/z_new "https://github.com/$GITHUB_REPO/releases/download/$REMOTE_VER/zoraxy_linux_amd64"; then
                   run_sudo systemctl stop "$SERVICE_NAME"
                   [ -f "$ZORAXY_HOME/zoraxy" ] && run_sudo mv "$ZORAXY_HOME/zoraxy" "$ZORAXY_HOME/zoraxy.old"
                   run_sudo mv /tmp/z_new "$ZORAXY_HOME/zoraxy"
                   run_sudo chmod +x "$ZORAXY_HOME/zoraxy"
                   echo "$REMOTE_VER" | run_sudo tee "$VERSION_FILE" > /dev/null
                   run_sudo systemctl start "$SERVICE_NAME"
                   echo -e "${GREEN}Succ√®s.${NC}"; pause
               else echo -e "${RED}Erreur download.${NC}"; pause; fi ;;
            2) if [ "$RB_OK" == "true" ]; then
                   if ! ask_sudo_gui; then continue; fi
                   run_sudo systemctl stop "$SERVICE_NAME"
                   run_sudo mv "$ZORAXY_HOME/zoraxy" "$ZORAXY_HOME/zoraxy.failed"
                   run_sudo mv "$ZORAXY_HOME/zoraxy.old" "$ZORAXY_HOME/zoraxy"
                   run_sudo chmod +x "$ZORAXY_HOME/zoraxy"
                   echo "Rollback" | run_sudo tee "$VERSION_FILE" > /dev/null
                   run_sudo systemctl start "$SERVICE_NAME"
                   echo -e "${GREEN}Restaur√©.${NC}"; pause
               fi ;;
            3) if ask_sudo_gui; then echo -e "\n${CYAN}APT UPDATE${NC}"; sudo apt-get update; echo -e "\n${CYAN}APT UPGRADE${NC}"; sudo apt-get upgrade -y; echo -e "\n${GREEN}Fini.${NC}"; pause; fi ;;
            4) if ask_sudo_gui; then echo -e "\n${CYAN}APT DIST-UPGRADE${NC}"; sudo apt-get dist-upgrade -y; echo -e "\n${GREEN}Fini.${NC}"; pause; fi ;;
            5) if ask_sudo_gui; then sudo nano /etc/apt/sources.list; fi ;;
            0) return ;;
        esac
    done
}

# --- 6. WORKFLOW CHANGEMENT PORT ---

workflow_change_port() {
    echo -e "\n${BOLD}üîå CHANGEMENT DE PORT${NC}"
    echo -e "Actuel : ${YELLOW}$CURRENT_PORT${NC}"
    read -p "Nouveau (ex: 8080) : " P_INPUT
    NEW_PORT="${P_INPUT#:}"
    
    if [ -z "$NEW_PORT" ] || [ "$NEW_PORT" == "$CURRENT_PORT" ]; then echo "Annul√©."; return; fi
    if ! [[ "$NEW_PORT" =~ ^[0-9]+$ ]]; then echo -e "${RED}Invalide.${NC}"; return; fi

    if ! api_login; then return; fi

    echo -e "\n${YELLOW}Analyse VHosts...${NC}"
    OLD_LOC="127.0.0.1:$CURRENT_PORT"; OLD_LAN="$LOCAL_IP:$CURRENT_PORT"
    LIST=$(curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" --data-urlencode "type=host" "$API_URL/api/proxy/list")
    DOMS=$(echo "$LIST" | jq -r --arg t1 "$OLD_LOC" --arg t2 "$OLD_LAN" '.[] | select(.ActiveOrigins[].OriginIpOrDomain == $t1 or .ActiveOrigins[].OriginIpOrDomain == $t2) | .RootOrMatchingDomain')
    CNT=$(echo "$DOMS" | grep -v "^$" | wc -l)

    echo -e "\n${BLUE}R√©sum√© :${NC} $CNT site(s) √† migrer vers $NEW_PORT"
    if [ "$CNT" -gt 0 ]; then echo -e "Sites : $(echo $DOMS | tr '\n' ' ')"; fi
    
    read -p "Confirmer ? (oui/non) : " c; if [ "$c" != "oui" ]; then return; fi

    if ! ask_sudo_gui; then return; fi

    if [ "$CNT" -gt 0 ]; then
        echo "Migration VHosts..."
        NEW_T="127.0.0.1:$NEW_PORT"
        echo "$DOMS" | while read -r d; do
            [ -z "$d" ] && continue
            curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" --data-urlencode "ep=$d" --data-urlencode "origin=$OLD_LOC" --data-urlencode "payload={\"OriginIpOrDomain\":\"$NEW_T\"}" --data-urlencode "active=true" "$API_URL/api/proxy/upstream/update" >/dev/null
            curl -s -k -b "$COOKIE_FILE" -H "X-CSRF-Token: $CSRF_TOKEN" --data-urlencode "ep=$d" --data-urlencode "origin=$OLD_LAN" --data-urlencode "payload={\"OriginIpOrDomain\":\"$NEW_T\"}" --data-urlencode "active=true" "$API_URL/api/proxy/upstream/update" >/dev/null
            echo " - $d OK"
        done
    fi

    echo "Pare-feu..."
    sudo ufw allow "$NEW_PORT/tcp" >/dev/null
    echo "Service..."
    S_FILE=$(systemctl show -p FragmentPath "$SERVICE_NAME" | cut -d= -f2)
    sudo sed -i "s|\-port=:[0-9]*|-port=:$NEW_PORT|g" "$S_FILE"
    sudo systemctl daemon-reload
    sudo systemctl restart "$SERVICE_NAME"
    echo "Nettoyage..."
    if [ "$CURRENT_PORT" != "$NEW_PORT" ]; then sudo ufw delete allow "$CURRENT_PORT/tcp" >/dev/null; fi
    CURRENT_PORT=$NEW_PORT; API_URL="http://127.0.0.1:$CURRENT_PORT"
    echo -e "${GREEN}Succ√®s.${NC}"; pause
}

# --- 7. AUTRES FONCTIONS ---

firewall_checkbox_delete() {
    mapfile -t RULES < <(run_sudo ufw status numbered | grep "^\[")
    if [ ${#RULES[@]} -eq 0 ]; then echo "Aucune r√®gle."; pause; return; fi
    declare -a SEL; for i in "${!RULES[@]}"; do SEL[$i]=false; done
    while true; do
        clear; echo -e "${RED}${BOLD}SUPPRESSION UFW${NC}"
        for i in "${!RULES[@]}"; do
            NUM=$(echo "${RULES[$i]}" | sed -E 's/^\[([ 0-9]+)\].*/\1/' | xargs)
            DESC=$(echo "${RULES[$i]}" | sed -E 's/^\[[ 0-9]+\] //')
            if [ "${SEL[$i]}" == "true" ]; then M="${RED}‚úñ DEL${NC}"; else M="${GREEN}‚úî OK ${NC}"; fi
            printf " %b | %2s | %s\n" "$M" "$NUM" "$DESC"
        done
        echo -e "[a] Tout | [n] Rien | [v] VALIDER | [q] Retour"
        read -r -p "> " k
        if [[ "$k" =~ ^[0-9]+$ ]]; then
            for i in "${!RULES[@]}"; do
                rn=$(echo "${RULES[$i]}" | sed -E 's/^\[([ 0-9]+)\].*/\1/' | xargs)
                if [ "$rn" == "$k" ]; then if [ "${SEL[$i]}" == "true" ]; then SEL[$i]=false; else SEL[$i]=true; fi; fi
            done
        elif [ "$k" == "v" ]; then
            declare -a DELS
            for i in "${!RULES[@]}"; do
                if [ "${SEL[$i]}" == "true" ]; then
                    rn=$(echo "${RULES[$i]}" | sed -E 's/^\[([ 0-9]+)\].*/\1/' | xargs)
                    DELS+=("$rn")
                fi
            done
            if [ ${#DELS[@]} -gt 0 ]; then
                if ask_sudo_gui; then
                    SORTED=$(printf "%s\n" "${DELS[@]}" | sort -nr)
                    for n in $SORTED; do yes | sudo ufw delete "$n" >/dev/null; done
                    echo -e "${GREEN}Termin√©.${NC}"; pause; break
                fi
            fi
        elif [ "$k" == "q" ]; then break
        elif [ "$k" == "a" ]; then for i in "${!RULES[@]}"; do SEL[$i]=true; done
        elif [ "$k" == "n" ]; then for i in "${!RULES[@]}"; do SEL[$i]=false; done
        fi
    done
}

server_power_action() {
    echo -e "\n${RED}${BOLD}‚ö†Ô∏è  ATTENTION : $1 DU SYST√àME${NC}"
    read -p "Tapez 'confirmer' : " i
    if [ "$i" == "confirmer" ]; then 
        run_sudo $2
        exit 0
    else echo "Annul√©."; pause; fi
}

# --- 8. MENUS ---

menu_config() {
    while true; do
        clear; detect_api_url; S_FILE=$(systemctl show -p FragmentPath "$SERVICE_NAME" | cut -d= -f2)
        if grep -q "\-noauth" "$S_FILE" 2>/dev/null; then AS="${RED}NON${NC}"; AA="üîí Activer Auth"; else AS="${GREEN}OUI${NC}"; AA="üîì D√©sactiver Auth"; fi
        echo -e "${BLUE}=== CONFIGURATION ===${NC}"
        echo -e "Port: ${YELLOW}$CURRENT_PORT${NC} | Auth: $AS"
        echo "---------------------"
        echo -e "1. Changer Port"
        echo -e "2. $AA"
        echo -e "3. √âdition Manuelle"
        echo -e "0. Retour"
        read -r -p "> " c
        case "$c" in
            1) workflow_change_port ;;
            2) if ask_sudo_gui; then if grep -q "\-noauth" "$S_FILE"; then sudo sed -i "s| -noauth||g" "$S_FILE"; else sudo sed -i "/ExecStart/ s/$/ -noauth/" "$S_FILE"; fi; sudo systemctl daemon-reload; sudo systemctl restart "$SERVICE_NAME"; pause; fi ;;
            3) if ask_sudo_gui; then sudo nano "$S_FILE"; sudo systemctl daemon-reload; pause; fi ;;
            0) return ;;
        esac
    done
}

menu_firewall() {
    while true; do
        clear
        if run_sudo ufw status | grep -q "active"; then ST="${GREEN}ACTIF${NC}"; else ST="${RED}INACTIF${NC}"; fi
        echo -e "${BLUE}=== PARE-FEU ($ST) ===${NC}"
        if [[ "$ST" == *ACTIF* ]]; then run_sudo ufw status numbered; fi
        echo "----------------------"
        echo -e "1. Ouvrir Web (80/443)"
        echo -e "2. Ouvrir SSH (22)"
        echo -e "3. Activer UFW"
        echo -e "4. Supprimer (Checkbox)"
        echo -e "5. D√©sactiver UFW"
        echo -e "0. Retour"
        read -r -p "> " u
        case "$u" in
            1) run_sudo ufw allow 80/tcp; run_sudo ufw allow 443/tcp; pause ;;
            2) run_sudo ufw allow 22/tcp; pause ;;
            3) run_sudo ufw enable; pause ;;
            4) firewall_checkbox_delete ;;
            5) run_sudo ufw disable; pause ;;
            0) return ;;
        esac
    done
}

menu_backup() {
    if [ ! -d "$BACKUP_DIR" ]; then run_sudo mkdir -p "$BACKUP_DIR"; fi
    while true; do
        clear; echo -e "${BLUE}=== SAUVEGARDES ===${NC}"; ls -lh "$BACKUP_DIR" | grep "tar.gz" | awk '{print "üìÑ " $9 " (" $5 ")"}'
        echo "-------------------"
        echo -e "1. Cr√©er"
        echo -e "2. Supprimer"
        echo -e "0. Retour"
        read -r -p "> " b
        case "$b" in
            1) if ask_sudo_gui; then T=$(date +%Y%m%d_%H%M); sudo bash -c "cd $ZORAXY_HOME && tar --exclude='zoraxy' --exclude='*.tar.gz' -czf '$BACKUP_DIR/bkp_$T.tar.gz' ."; echo "OK"; pause; fi ;;
            2) 
               mapfile -t L < <(ls "$BACKUP_DIR"/*.tar.gz 2>/dev/null | xargs -n 1 basename)
               for i in "${!L[@]}"; do echo "$((i+1)). ${L[$i]}"; done
               read -p "Num√©ro > " d
               if [[ "$d" =~ ^[0-9]+$ ]]; then T="${L[$((d-1))]}"; if [ -n "$T" ] && ask_sudo_gui; then sudo rm "$BACKUP_DIR/$T"; echo "Supprim√©"; pause; fi; fi ;;
            0) return ;;
        esac
    done
}

menu_vhost_ssl() {
    while true; do
        clear; show_vhost_table_local
        echo -e "1. Ajouter Site"
        echo -e "2. Modifier Cible"
        echo -e "3. Supprimer"
        echo -e "4. G√©n√©rer SSL"
        echo -e "5. Renouveler SSL"
        echo -e "0. Retour"
        read -r -p "> " c
        case "$c" in 
            1) api_add_host ;; 2) api_edit_host ;; 3) api_del_host ;; 4) generate_ssl_api ;; 5) renew_ssl_checkbox ;; 0) return ;; 
        esac
    done
}

# --- 9. MAIN ---

# Longueur de la ligne d'en-t√™te (45 caract√®res)
HEADER_LINE="#############################################"

while true; do
    clear; check_requirements; get_sys_info
    
    # 1. √âtat du service Zoraxy (v√©rifi√©)
    ST=$(systemctl is-active --quiet "$SERVICE_NAME" && echo "${GREEN}‚óè ON${NC}" || echo "${RED}‚óè OFF${NC}")
    
    # 2. √âtat du pare-feu UFW (v√©rifi√©)
    if run_sudo ufw status | grep -q "active"; then FW_ST="${GREEN}‚óè ACTIF${NC}"; else FW_ST="${RED}‚óè INACTIF${NC}"; fi
    
    # MODIFICATION D'ALIGNEMENT
    echo -e "${BLUE}$HEADER_LINE${NC}"
    echo -e "${BLUE}#         ZORAXY MANAGER - DASHBOARD        #${NC}"
    echo -e "${BLUE}$HEADER_LINE${NC}"
    
    # Ligne 1 : Statuts des services
    printf "  üîå Zoraxy : %-15b | üõ°Ô∏è  Pare-feu : %s\n" "$ST" "$FW_ST"
    
    # Ligne 2 : IP locale
    echo -e "  üíª IP locale : ${YELLOW}$LOCAL_IP${NC}"
    
    # Ligne 3 : IP publique
    echo -e "  üåç IP publique : ${YELLOW}$PUBLIC_IP${NC}"
    
    echo "---------------------------------------------"
    echo -e "  ${GREEN}1.${NC} ‚ñ∂Ô∏è  D√©marrer"
    echo -e "  ${GREEN}2.${NC} ‚èπÔ∏è  Arr√™ter"
    echo -e "  ${GREEN}3.${NC} üîÑ Red√©marrer"
    echo -e "  ${GREEN}4.${NC} üìú Logs"
    echo ""
    echo -e "  ${GREEN}5.${NC} üì¶ Sauvegardes"
    echo -e "  ${GREEN}6.${NC} üöÄ Mises √† jour (App & OS)"
    echo -e "  ${GREEN}7.${NC} ‚öôÔ∏è  Config Daemon"
    echo -e "  ${GREEN}8.${NC} üåê VHosts & SSL"
    echo -e "  ${GREEN}9.${NC} üõ°Ô∏è  Pare-Feu"
    echo -e "  ${GREEN}10.${NC}üîí Shell Restreint"
    echo ""
    echo -e "  ${RED}11.${NC}üîå √âteindre"
    echo -e "  ${RED}12.${NC}‚ôªÔ∏è  Reboot System"
    echo "---------------------------------------------"
    echo -e "  [${YELLOW}admin${NC}] üíª Console Admin"
    echo -e "  [${RED}exit${NC}]  üö™ Quitter"
    echo "---------------------------------------------"
    read -r -p "> " ch

    case "$ch" in
        1) run_sudo systemctl start "$SERVICE_NAME"; sleep 1 ;;
        2) run_sudo systemctl stop "$SERVICE_NAME"; sleep 1 ;;
        3) run_sudo systemctl restart "$SERVICE_NAME"; sleep 1 ;;
        4) trap - SIGINT; run_sudo journalctl -u "$SERVICE_NAME" -f -n 50; trap '' SIGINT ;;
        5) menu_backup ;;
        6) menu_update_center ;;
        7) menu_config ;;
        8) menu_vhost_ssl ;;
        9) menu_firewall ;;
        10) spawn_restricted_shell "$ZORAXY_HOME" "Config" ;;
        11) server_power_action "√âTEINDRE" "poweroff" ;;
        12) server_power_action "RED√âMARRER" "reboot" ;;
        admin) open_user_shell ;;
        exit|q) kill -9 $PPID; exit 0 ;;
    esac
done
    esac
done
